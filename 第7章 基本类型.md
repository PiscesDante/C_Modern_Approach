# 第7章 基本类型

计算机处理的是数而不是符号。

## 7.1 整数类型

C语言支持两种根本不同的数值类型：整数类型（整型）和浮点类型（浮点型）。整数类型的值是整数，而浮点类型的值则可能还有些小数部分。整数类型又分为两大类：有符号类型和无符号类型。

#### 有符号整数和无符号整数

有符号整数如果为正数或者零，那么最左边的位（符号位）为0；如果是负数，则符号位为1。不带符号位的整数称为无符号整数。**默认情况下，C语言中的整形变量都是有符号的，也就是说最左位保留符号位**。

C语言允许通过省略单词int来缩写整数类型的名字：

```C
unsigned short int => unsigned short
long int => long
```

整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则：

* C标准要求short、int、long中的每一种类型都要覆盖一个确定的最小取值范围。
* 标准要求int类型不能比short类型短，long类型不能比int类型短。

确定整数类型范围的一种方法是检查`<limits.h>`头文件。

### 7.1.1 C99中的整数类型

C99提供了两个标准整数类型：long long和unsigned long long。这两个基本上不是特别常用。

### 7.1.2 整数常量

常量：在程序中以文本形式出现的数，而不是读、写或者计算出来的数。

* 十进制：常量包含0-9中的数字，但是一定不能以零开头——15 255 32767
* 八进制：常量只包含0-7中的数字，而且必须要以零开头——017 0377 077777
* 十六进制：常量包含0-9中的数字和a-f中的字母，而且总是以0x开头——0xFF

八进制和十六进制只是数字的一种书写方式，它们不会对数的实际存储方式产生影响。任何时候都可以从一种书写方式切换到另一种书写方式。甚至可以混合使用：`15 + 025 + 0xAF`。八进制和十六进制往往用于底层程序的编写。

### 7.1.3 C99中的整数常量

### 7.1.4 整数溢出

对整数执行算术运算时，其结果有可能因为太大而无法表示。整数溢出时的行为要根据操作数是有符号还是无符号来确定。有符号整数运算中发生溢出时，程序的行为是未定义的。无符号整数运算过程中发生溢出时，结果是有定义的：正确答案是对2的n次方取模，其中n是用于存储结果的位数。类似于钟表的溢出，即12点之后指针会指向1点。

### 7.1.5 读写整数

* 读写**无符号整数**时，使用字母u、o或者x代替转换说明中的d。
* 读写**短整数**时，在d、o、u或者x前面加上字母h（s被字符串占用）。
* 读写**长整数**时，在d、o、u或者x前面加上字母l。
* 读写**长长整数**时，在d、o、u或者x前面加上字母ll。

切记：**当有符号整数发生溢出时，结果是未定义的**。

## 7.2 浮点类型

C语言提供了三种浮点类型，对应三种不同的浮点格式：

* float：单精度浮点数。
* double：双精度浮点数。
* long double：扩展精度浮点数。

double提供的精度对于绝大多数程序来说都够用了。long double支持极高的精度要求，很少会用到。

C99中，浮点类型分为两种：**浮点实类型**和**复数类型**。

### 7.2.1 浮点常量

浮点常量必须包含小数点或者指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。默认情况下，浮点常量都以双精度的形式存储。当C语言编译器在程序中发现常量57.0时，它会安排数据以双精度的形式存储在内存中。这条规则通常不会引发任何问题。

### 7.2.2 读写浮点数

转换说明符%e，%f，%g用于读写单精度浮点数。读写double和long double类型的值所需的转换说明符略有不同。

* 读取double类型的值时，在e、f或者g前放置字母l：

  ```C
  double d;
  scanf("%lf", &d); // 读取double类型的
  ```

* 读写long double类型的值时，在e、f或g前放置字母L：

  ```C
  long double ld;
  scanf("%Lf", &ld);
  printf("%Lf", ld);
  ```

## 7.3 字符类型

char类型就是字符类型。char类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。

char类型的变量可以用任意单字符赋值：

```C
char ch;
ch = 'A'; // 字符常量需要用单引号括起来，而不是双引号。
```

### 7.3.1 字符操作

因为存在这样一个事实：**C语言把字符当作小整数进行处理**。因为所有的字符都是以二进制的形式进行编码的，而且无需花费太多的想想就可以将这些二进制的代码看成整数。

**字符常量**事实上是int类型而不是char类型。

可以像比较数那样对字符进行比较。诸如`'a' <= ch`这样的比较使用的是字符所对应的整数值，这些数值根据使用的字符集有所不同。

字符拥有和数相同的苏醒，这一事实会带来一些好处。毕竟我们可以像遍历数字那样来遍历字母表。

```C
#include <iostream>

int main(int argc, char const *argv[])
{
    for (char i = 'a'; i <= 'z'; ++i) // 如果这里将i声明为int打印出来的就是整数
        std::cout << i << " "; // a b c ...
    std::cout << std::endl;
    return 0;
}
```

### 7.3.2 有符号字符和无符号字符

C语言标准允许使用单词signed和unsigned来修饰char类型。

### 7.3.3 算术类型

整数类型和浮点数类型统称算术类型。

* 整值类型：字符数型（char），有符号整型，无符号整型，枚举类型。
* 浮点类型：实数浮点类型，复数类型。

### 7.3.4 转义序列

一些不可见的，非打印字符或者无法从键盘输入的字符被划分成为转义序列。

转义序列一共有两种：

* 字符转义序列
* 数字转义序列

### 7.3.5 字符处理函数

使用if语句将小写字母转换为大写字母的方法：

```C
if ('a' <= ch && ch <= 'z') return ch - 'a' + 'A';
```

当然也可以使用C语言的toupper库函数：

```C
#include <ctype.h>
char up = toupper(ch);
```

### 7.3.6 用scanf和printf读写字符

转换说明符%c允许scanf函数和printf函数对单个字符进行读写：

```C
char ch;
scanf("%c", &ch); // 读一个字符
printf("%c", ch); // 打印一个字符
```

在读入字符之前，scanf函数不会跳过空白字符。如果下一个未读字符是空格，那么在前面的例子中，scanf函数返回后变量ch将包含一个空格。为了强制scanf函数在读入字符前跳过空白字符，那么就需要在格式串中的转换说明%c前面加上一个空格：

```C
scanf(" %c", &ch); // 这样空格就会直接匹配掉开始的所有空格字符
```

**scanf格式串中的空白意味着“跳过零个或者多个空白字符”**。

### 7.3.7 用getchar和putchar读写字符

putchar函数用于写单个字符：

```C
char ch;
putchar(ch); // 打印出ch的内容
```

每次调用getchar函数时，它会读入一个字符并且将其返回。为了保存这个字符，必须使用赋值操作将其存储到变量中：

```C
char ch;
ch = getchar(); // 从输入中获得一个字符然后存储在ch中
```

事实上，getchar函数返回的是一个**int类型的值**而不是char类型的值。如果一个变量用于存储getchar函数读取的字符，其类型设置为int而不是char也是可行的。和scanf函数一样，getchar函数也不会在读取字符时跳过空白字符。

执行程序时，使用getchar函数和putchar函数可以节约时间。这两个函数执行速度快有两个原因：

* 这两个函数比scanf和printf函数简单的多，因为后两者牵扯到格式化的问题。
* 为了额外的速度提升，通常getchar和putchar函数是作为宏来实现的。

因为getchar返回的是读入的字符，所以getchar函数可以应用在多种不同的C语言习惯用法中。

如果在同一个程序中混合使用getchar函数和scanf函数，请一定要注意：scanf函数倾向于遗留下它扫描过但是未读取的字符（包括换行符）：

```C
#include <cstdio>
#include <iostream>

int main(int argc, char const *argv[])
{
    int i;
    char command;
    printf("Enter an integer: "); // 如果我们这里输入12A
    scanf("%d", &i); // 这里scanf函数读取12，然后在A前面停下来
    printf("Enter a command: ");
    command = getchar(); // 这里getchar函数会直接从scanf函数剩下的部分，也就是A字符开始读
    std::cout << i << " " << command << std::endl; // 输出
    // 最终程序的输出结果：Enter a command: 12 A
    return 0;
}
```

#### 程序：确定消息的长度

```C
/**************************************
 * Determines the length of a message.*
 **************************************/

#include <stdio.h>

int main(int argc, char const *argv[])
{
    int counter;
    printf("Enter a message: ");
    for (counter = 0; getchar() != '\n'; ++counter);
    printf("Your message was %d character(s) long.\n", counter);
    return 0;
}

// Result：
// Enter a message: Brevity is the soul of wit.
// Your message was 27 character(s) long.
```

## 7.4 类型转换

为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。计算机可能将两个16位整数相加，但是不能直接将16位整数和32位整数相加。

C语言允许在表达式中混合使用基本类型。在单个表达式中可以组合整数、浮点数，甚至是字符。当然，这种情况下C编译器可能需要生成一些指令将某些操作数转换成为不同的类型，使得硬件可以进行表达式计算。

因为编译器可以自动处理这些转换而无需程序员的介入，所以这类转换称为**隐式转换**。

C语言还允许程序员使用强制运算符执行**显式转换**。

#### 当发生下列情况时会进行隐式转换

* 当算术表达式或者逻辑表达式中操作数类型不相同时（常用算术转换）。
* 当运算符右侧表达式的类型和左侧变量的类型不匹配时。
* 当函数调用中的实参类型与其对应的形参类型不匹配时。
* 当return语句中的表达式的类型和函数返回值的类型不匹配时。

### 7.4.1 常用算术转换

常用的算术转换策略是**把操作数转换成可以·安·全·的·适用于·两·个·数值的“最狭小的”数据类型**。

狭小：如果A类型要求的存储位数比B类型少，那么就说A类型比B类型狭小。

为了统一操作数的类型，通常可以将相对狭小的类型的操作数转换成另一个操作数的类型来实现（这就是所谓的提升）。最常用的提升就是整型提升，它把字符或短整数转换成int类型。

#### 执行常用算术转换的规则可以划分成两种情况

* 任一操作数的类型是浮点类型的情况：`float => double => long double`。
* 两个操作数的类型都不是浮点类型的情况：`int => unsigned int => long int => unsigned long int`。

当把有符号操作数和无符号操作数组合时，会把有符号操作数“转换”称无符号的值。由于此类陷阱的存在，**所以最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用**。

### 7.4.2 赋值过程中的转换

常用算术转换不适用于赋值运算。C语言会遵循另一条简单的转换规则：**把赋值运算符右边的表达式转换成左边变量的类型**。如果变量的类型至少和表达式类型一样“宽”，那么就没有任何转换问题。

当把浮点数赋值给整形变量时，变量会**直接丢掉小数部分**，这种现象叫做“截断”。

如果浮点常量被赋值给float类型的变量时，一定要在浮点常量尾部加上后缀f。如果没有后缀，常量3.14将是double类型，可能会引起警告消息。

### 7.4.3 C99中的隐式转换

### 7.4.4 强制类型转换

C语言提供了强制类型转换。强制转换表达式的格式如下：`(类型名)表达式`。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    float val;
    float frac_part;
    val = 3.14f;
    frac_part = val - (int)val; // 0.14
    return 0;
}
```

C语言把`(类型名)`视为一元运算符。一元运算符的优先级高于二元运算符。

## 7.5 类型定义

一个更好的设置布尔类型的方法是利用所谓的类型定义的特性：

```C
typedef int Bool; // 这里注意，所定义的类型名要放在最后！！！
```

这时编译器将把Bool类型看成是int类型的同义词。

### 7.5.1 类型定义的优点

### 7.5.2 类型定义和可移植性

## 7.6 sizeof运算符

**sizeof运算符允许程序存储指定类型值所需空间的大小**：`sizeof(类型名)`。

sizeof运算符返回的值始终是一个无符号的整数，代表存储当前类型的值所需要的**·字·节·数·**。

sizeof运算符是一种特殊的运算符，因为编译器本身就可以确定sizeof表达式的值。

sizeof作为一元运算符的优先级要高于二元运算符。所以在**使用sizeof运算符时一定要始终加上圆括号**。