# 第12章 指针和数组

当指针指向数组元素时，C 语言允许对指针进行算术运算（加法和减法），通过这种运算我们可以 **用指针代替数组下标对数组进行处理** 。

## 12.1 指针的算术运算

```C++
int arr[10]; // 声明一个长度为 10 的数组 arr
int* arrp = &arr[0]; // 指向数组 arr 的第一个元素

// 可以通过 arrp 访问 arr[0] ，比方说把 5 存入 arr[0] ：
*arrp = 5; // 等价于 arr[0] = 5
```

通过在 `arrp` 上执行指针算术运算（或者地址算术运算符）可以访问数组 `arr` 的其他所有元素。C 语言支持且仅支持三种格式的指针算术运算：

* 指针加上一个整数；
* 指针减去一个整数；
* 两个指针相减；

### 12.1.1 指针加上整数

指针 `arrp` 加上整数 `j` 产生指向特定元素的指针，这个特定的元素是 `arrp` 原本指向的元素后 `j` 个位置。确切的说：**<u>如果 `arrp` 指向元素 `arr[i]` ，那么 `arrp + j` 指向 `arr[i + j]`</u>** 。

### 12.1.2 指针减去整数

如果 `arrp` 指向元素 `arr[i]` ，那么 `arrp - j` 指向 `arr[i - j]` 。

### 12.1.3 两个指针相减

当两个指针相减时，结果为指针之间的距离（用数组元素的个数来度量）。

```C++
int* p1 = &arr[5];
int* p2 = &arr[1];
int i = p1 - p2; // i is 5 - 1 == 4
int j = p2 - p1; // j is 1 - 5 == -4
```

**<u>在不指向任何数组元素的指针上执行算术运算会导致未定义的行为</u>** 。并且只有两个指向同一数组的指针相减才有意义。

### 12.1.4 指针比较

**只有在两个指针指向同一数组时，用关系运算符进行的指针比较才有意义** 。比较的结果依赖于数组中两个元素的相对位置。

### 12.1.5 指向复合常量的指针（ C99 ）

## 12.2 指针用于数组处理

指针的算术运算允许通过对指针变量进行 **重复自增** 来访问数组的元素：

```C++
int arr[5] = {0}; // 0, 0, 0, 0, 0
for (int i = 1, *p = &arr[0]; i <= 5; ++i, ++p) { *p = i; }
// Now the arr is: 1, 2, 3, 4, 5
```

#### 间接寻址运算符和自增运算符的组合

```C++
arr[i++] = j; // 先把 j 赋值给 arr[i] ，然后 i 自增 1
*arrp++ = j; // 因为后缀 ++ 的优先级高于间接寻址运算符，所以等价于：
*(arrp++) = j; // arrp++ 的值是 arrp ，所以这三条语句等价
// 当然这个地方最好加上括号，因为这个运算符优先级记忆起来很麻烦而且易错
```

## 12.3 用数组名作为指针使用

* 可以使用数组的名字作为指向数组第一个元素的指针。
* 虽然可以把数组名作为指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的。
* 当使用数组名作为指针的时候，「数组名指针」相当于一个顶层 `const` 指针（不能改变指针本身）。

### 12.3.1 数组型实际参数

**数组名在传递给函数时，总是被视为指针** 。把数组形式参数看作是指针会产生很多重要的结果：

* 在给函数传递普通变量时，变量值会被复制；任何相对应的形式参数的改变都不会影响到变量。反之，因为没有对数组本身进行复制，所以作为实际参数的数组是 **可能** 被改变的。

  为了指明数组形参（也就是实参）不会被改变，可以在声明中加入 `const` ：

  ```C++
  int find_largest(const int arr[], int n) {
      ...
  }
  ```
* 给函数传递数组所需的时间与数组大小无关。
* 可以把数组形参声明为指针，编译器把这两类声明看作是完全一样的。 **对于数组形参而言，声明为数组和声明为指针是完全一样的** 。
* 可以给形式参数为数组的函数传递数组的片段。

### 12.3.2 用指针作为数组名

## 12.4 指针和多维数组

TODO