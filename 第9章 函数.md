# 第9章 函数

函数简单来说就是一连串的语句，这些语句被组合在一起，并被指定了一个名字。

C语言中，函数不一定要有参数，但也不一定要计算数值。

函数是C程序的构件块。每个函数本质上是一个自带声明和语句的小程序。可以利用函数把程序划分成小块，这样便于理解、修改和复用程序。

## 9.1 函数的定义和调用

#### 程序：计算平均值

```C
/******************************
 * Caculate the average value *
 ******************************/
double average(double v1, double v2) { return (a + b) / 2; }
```

函数开始处放置的单词double表示average函数的**返回类型**，也就是每次调用该函数时返回的数据类型。标识符v1和标识符v2（即函数的**形式参数**）表示在调用average函数时需要提供的两个数。每一个形式参数都必须有类型。函数的**形式参数本质上是变量**，其初始值在调用函数的时候才提供。

每个函数都有一个用花括号括起来的执行部分，称为**函数体**。

为了调用函数，需要写出函数名以及跟随其后的**实际参数列表**。调用函数就是把实际参数的值**复制**给形式参数，然后执行函数体。

如果函数没有任何返回值，那么就使用void指明它的返回值类型，并且省略return语句。并且调用没有返回值得函数调用语句必须自成一个语句。

对于一些根本没有形式参数的函数，可以声明为：

```C
void func1();
void func2(void);
```

两种声明方式都是可以的，其中后者的形参列表中由void作为占位符。

### 9.1.1 函数定义

函数定义的一般格式：

```C
返回类型 函数名 (形式参数)
{
    声明
    语句
}
```

函数的返回类型是函数返回值的类型。下列规则用来管理返回类型：

* 函数不能返回数组！但是关于返回类型没有其他限制。
* 指定返回类型是void类型说明函数没有返回值。
* 如果省略返回类型，C89会默认为int类型，但是C99中是非法的。
* 如果返回类型很冗长，那么把返回类型放在单独的一行是非常有用的。

需要在每个形式参数的前面说明其类型，形式参数之间使用逗号进行分隔。

如果函数没有形式参数，那么在圆括号里面最好应该出现void。

### 9.1.2 函数调用

函数调用由函数名和跟随其后的实际参数列表组成，其中实际参数列表使用圆括号括起来，圆括号被称为**函数调用运算符**。

注意，printf函数返回显示的字符个数。

为了清楚的表示函数的返回值是被故意丢掉的，C语言允许在函数调用前加上`(void)`：

```C
(void) printf("Hello World\n"); // 强制转换成void即丢弃返回值
```

#### 程序：判定素数

```C
/***********************************
 * Check whether a number is prime *
 ***********************************/

#include <stdio.h>
#include <stdbool.h>

bool is_prime(int val); /*** 函数的前置声明 ***/

int main(int argc, char const *argv[])
{
    int num;
    printf("Enter a number: ");
    scanf("%d", &num);
    if (is_prime(num)) {
        printf("Is prime.");
    } else {
        printf("Not prime.");
    }
    return 0;
}

bool is_prime(int val)
{
    int half = val / 2;
    for (int i = 2; i <= half; ++i) {
        if (val % 2 == 0) return false;
    }
    return true;
}

// Enter a number: 34
// Not prime.
// Enter a number: 13
// Is prime.
```

在一个函数中可以声明与另一个函数中变量同名的变量，因为这两个变量分属不同的作用域，所以在内存中的地址也不相同。

函数中可以有多条return语句。但是在任何一次函数调用中只能执行其中一条return语句，这是因为**到达return语句之后程序控制器就会返回到函数调用点**。

## 9.2 函数声明

在调用前声明每个函数。**函数声明使得编译器可以先对函数进行概要浏览，而函数的完整定义以后再给出**。

函数声明的格式：`返回类型 函数名(形式参数);`

这种函数声明称为函数原型。原型为如何调用函数提供了完整的描述：提供了多少实际参数，这些参数应该是什么类型，以及返回的结果是什么类型。

C99遵循这样的规则：**在调用一个函数之前，必须先对其进行声明或者定义。调用函数时，如果此前编译器未见到该函数的声明或者定义，就会报错**。

## 9.3 实际参数

形式参数：出现在函数定义中，它们以“假名字”来表示函数调用时需要调用的值。

实际参数：出现在函数调用中的表达式。

C语言中，实际参数是通过**值传递**的！是通过值传递的！是通过值传递的！也就是说，**在调用函数的时候，计算出每个实际参数的值并且把它复制给相应的形式参数。在函数执行的过程中，对形式参数的改变不会影响实际参数的值。**

### 9.3.1 实际参数的转换

C语言允许在实际参数的类型与形式参数的类型不匹配的情况下完成函数的调用。

* 编译器在调用前遇到原型：每个实际参数的值被隐式的转换成相应的形式参数的类型。
* 编译器在调用前没有遇到原型。编译器报错。

### 9.3.2 数组型实际参数

当形式参数是一维数组时，可以不说明数组的长度：

```C
int func(int arr[]) // 这里不用说明数组的长度
{
    ...
}
```

实际参数可以是元素类型正确的任何一维数组。但是在C语言中，**没有为函数提供·任·何·简·便·的·方·法·来·确·定·传·递·给·它·的·数·组·的·长·度·，如果需要函数知道数组的长度，我们·必·须·要·把·数·组·的·长·度·作·为·额·外·的·参·数·提·供·出·来·**。

虽然可以使用sizeof运算符计算出数组变量的长度，但是**无法计算出关于数组形式参数的正确长度**。

把数组名传递给函数时，不要在数组名的后面放置方括号，直接传入数组的名字就好。

#### 关于数组型实际参数的重要论点

* **函数无法检测传入的数组长度的正确性**。
* **函数可以改变数组型形式参数的元素**，而且改变会在相应的实际参数中体现出来。
* 如果形式参数是多维数组，声明参数时只能省略第一维的长度。

###  9.3.3 变长数组形式参数（C99）

如果使用变长数组形式参数，我们可以明确说明数组arr的长度就是n：

```C
int sum_array(int n, int arr[n]) {
    ...
}
```

第一个参数n的值确定了第二个参数arr的长度。注意：这里交换了形式参数的顺序，使用变长数组形式参数时参数的顺序很重要，比方说下面的定义方式就是违法的：

```C
int sum_array(int arr[n], int n) { // 非法：n没有声明就被arr使用了
    ...
}
```

### 9.3.4 在数组参数声明中使用static（C99）

C99允许在数组参数声明中使用关键字static。

```C
int sum_array(int arr[static 3], int n) { // 将static放在数字3之前表明数组arr的长度至少可以保证是3
    ...
}
```

如果数组参数是多维的，static仅仅可以应用于第一维。

### 9.3.5 复合字面量（C99）

复合字面量：通过指定其包含的元素而创建的没有名字的数组。

复合字面量的格式：**现在一对圆括号内给定类型名，随后在一对花括号内设定所包括的元素的值**。

## 9.4 return语句

非void函数必须使用return语句来指定将要返回的值。当然如果没有给出表达式，return语句可以出现在返回类型为void的函数中。

程序使用非返回值函数的返回值的行为是未定义的。

## 9.5 程序终止

正常情况下，main函数的返回类型是int类型。

省略函数的返回类型在C99中是不合法的，所以禁止这样做。省略main函数的形参列表是合法的，但是从风格上来说最好显式的表明一个函数没有参数。

**main函数的返回值是状态码**，在某些操作系统中程序终止时可以检测到状态码。

#### exit函数

在main函数中执行return语句是一种终止程序的办法，另一种办法就是调用exit函数，此函数属于`<stdlib.h>`。传递给exit函数的实际参数和main函数的返回值具有相同的含义：两者都返回程序终止时的状态。

return语句和exit函数的区别是：**不管哪个函数调用exit函数都会导致程序终止**。

## 9.6 递归

如果函数要调用其自身，那么此函数就是递归的。

使用递归的核心要素在于终止条件，如果没有终止条件会产生无穷递归。