# 第13章 字符串

## 13.1 字符串字面量

**字符串字面量**是用一对双引号括起来的字符序列：`"Hello World"`

### 13.1.1 字符串字面量中的转义序列

**字符串字面量**可以像字符常量一样包含转义序列。

### 13.1.2 延续字符串字面量

如果字符串字面量太长而无法放置在单独一行内，只要把第一行用`\`字符结尾，那么C语言就允许在下一行延续字符串字面量。

使用`\`有个问题：**字符串字面量必须从下一行的起始位置继续，这就破坏了缩进结构**。这就需要一种更好的方法：**当两条或者更多条字符串字面量相邻时（仅用空白字符分割），编译器会自动把它们合成一条字符串**。

### 13.1.3 如何存储字符串字面量

本质上，**<u>C语言把字符串字面量作为字符数组来处理</u>**。当C语言编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n + 1的内存空间。这块内存空间将用来存储字符串字面量中的字符，**以及一个用来标志字符串末尾的格外字符（空字符）**。**空字符是一个所有位都为0的字节**，因此用转义序列`\0`来表示。空字符的ASCII编码值为0。

字符串字面量可以为空。字符串`""`作为单独一个空字符来存储，即看起来空的字符串中实际上有一个空字符`'\0'`。

既然字符串字面量是作为数组来存储的，那么编译器会把它看作是`char*`类型的变量。

### 13.1.4 字符串字面量的操作

通常情况下可以在任何C语言中允许使用char*类型变量的地方使用字符串字面量。

把字符串字面量赋给字符指针变量不是复制其中的字符，而是使字符指针指向字符串的第一个字符。

C语言允许对指针取下标，因此可以对字符串字面量取下标。

**试图改变字符串字面量会导致未定义的行为，改变字符串字面量可能会导致程序崩溃或者运行不稳定。**

### 13.1.5 字符串字面量与字符常量

只包含一个字符的字符串字面量不同于字符常量：字符串字面量`"a"`是用指针来表示的，这个指针指向存放字符串`"a"`（后面紧跟空字符）的内存单元。字符常量`'a'`是用整数（字符集的数值码）来表示的。

printf函数期望指针作为它的第一个参数。

## 13.2 字符串变量

只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。

千万要注意正确的处理空字符。而且，**要确定字符串长度没有比线性搜索空字符更快的方法了**。

当声明用于存放字符串的字符数组时，要始终保证**数组的长度比字符串的长度多一个字符**。这是因为C语言规定每个字符串都要以空字符结尾。如果没有给空字符预留位置，可能会导致未定义的结果，因为C函数库中的函数都市默认字符串是以空字符结束的。

**字符串的长度取决于空字符的位置，而不是却决于用于存放字符串的字符数组的长度**：

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char s[20] = "Hello World"; /* 初始化字符串变量 */
    for (int i = 0; i < 20; ++i) {
        if (s[i] == '\0') {
            putchar('\n');
            printf("Here is the end of the string!\n");
            printf("The index right now is: %d.\n", i);
            return 0;
        } else {
            putchar(s[i]);
        }
    }
    return 0;
}

// output:
// Hello World
// Here is the end of the string!
// The index right now is: 11.
```

### 13.2.1 初始化字符串变量

当我们时用字符串字面量初始化字符数组时，C编译器会把字符串字面量看成是数组初始化的缩写形式：

```C
char[20] s1 = "Hello World";
// 本质上等价于：
char[20] s1 = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
```

如果初始化式太短导致不能填满字符数组，编译器会把剩下的空间全部塞满空字符：

```C
char[15] s1 = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
// 等价于：
char[15] s1 = {'H','e','l','l','o',' ','W','o','r','l','d','\0','\0','\0','\0'};
```

比方说：

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char s[15] = "Hello World";
    for (int i = 0; i < 15; ++i) {
        if (s[i] == '\0') {
            printf("\\0");
        } else {
            putchar(s[i]);
        }
    }
    putchar('\n');
    return 0;
}

// output:
// Hello World\0\0\0\0
```

字符串字面量比字符数组长是非法的，严禁字符串字面量的长度超过字符数组的长度。

如果字符串字面量和字符数组等长，编译器不会报错，但是编译器会在赋值的时候忽略空字符，这样就使得这样的字符数组无法作为字符串使用。

### 13.2.2 字符数组与字符指针

```C
char date[] = "June 14";
char* date = "June 14";
```

前者声明的是一个数组，后者声明的是一个指针。上面两种都可以作为字符串的声明。任何期望传递字符数组或者字符串指针的函数都能接受这两种声明的date作为参数。

然而需要注意的是：不能错误的认为上面这两种date声明方式可以互换，两者存在很大的差异：

* **在声明为数组时，就像任意数组元素一样，可以修改存储在date中的字符。在声明为指针时，date指向的是一个字符串字面量，而字符串字面量是不可修改的。**
* **在声明为数组时，date是数组名。在声明为指针时，date是变量，这个变量可以在程序执行期间指向其他字符串。**

**如果希望可以修改字符串，那么就要建立字符数组来存储字符串**，声明指针变量就不行。

## 13.3 字符串的读写

### 13.3.1 用printf函数和puts函数写字符串

说明转换符`%s`允许printf函数写字符串：

```C
char str[] = "Hello World";
printf("%s\n", str);
```

printf函数会逐个写字符串中的字符，直到遇到空字符才停止。如果空字符丢失，printf函数会越过字符串的末尾继续写，直到在内存中碰到一个空字符才会停止（真的蠢……）。

如果只想显示字符串的一部分，可以使用转换说明`%.ps`，`p`是要显示的字符数量。

**puts函数只有一个参数，即需要显示的字符串。在写完字符串之后，puts函数总会添加一个额外的换行符，从而前进到下一个输出行的开始处。**

### 13.3.2 用scanf函数和gets函数读入字符串

调用scanf函数的时候，字符串参数之前不要添加取地址符，因为字符数组的名字或者字符指针本身就会被视为指针变量。调用时，scanf函数会跳过空白字符，然后在遇到空白字符之前把遇到的字符读入传入的字符串容器中。scanf函数始终会在字符串末尾添上一个空字符。

**使用scanf函数读入的字符串永远不会包含空白字符。**换行符、空格符和制表符都会使scanf函数停止读入。

为了一次读入一整行输入，需要使用gets函数。类似于scanf函数，**gets函数把读入的字符放到字符数组中，然后在末尾加上一个空字符**。然而在其他方面gets函数有些不同于scanf函数：

* gets函数不会在开始读入字符串之前跳过空白字符。
* gets函数会持续读入直到找到换行符才停止。gets函数会忽略掉换行符，不会把它存储在数组中。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char s1[50];
    char s2[50];
    printf("Enter a sentence: ");
    scanf("%s", s1);
    gets(s2);
    printf("What scanf got: %s\n", s1);
    printf("What gets got: %s\n", s2);
    return 0;
}

// Enter a sentence: To be or not to be, it is a question.
// What scanf got: To
// What gets got:  be or not to be, it is a question.
```

把字符读入数组时，scanf函数和gets函数都无法检测数组何时被填满。因此，它们存储字符时可能越过数组的边界，这会导致**未定义**的行为。

### 13.3.3 逐个字符读取字符串

## 13.4 访问字符串中的字符

字符串是以数组的方式存储的，因此可以使用下标来访问字符串中的字符。

## 13.5 使用C语言的字符串库

在C语言中把字符串当作数组来处理，因此对字符串的限制方式和对数组一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。**直接复制或者比较字符串都会失败**。

声明中的赋值运算符解释为初始化运算符，数组不可以被赋值但是可以被初始化。

C语言的字符串函数库位于`<string.h>`中。包含的函数每个至少需要一个字符串作为实际参数。字符串形式参数声明为char*类型。

### 13.5.1 strcpy函数

负责把s2复制给s1的的函数，原型如下：`char* strcpy(char* s1, const char* s2);`

```C
char* strcpy(char* s1, const char* s2)
{
    char* s1_temp = s1;
    char* s2_temp = s2;
    while (*s2_temp != '\0') {
        *s1_temp = *s2_temp;
        s1_temp += 1;
        s2_temp += 1;
    }
    s1_temp += 1;
    *s1_temp = '\0';
    return s1;
}
```

在strcpy函数的调用过程中，strcpy函数无法检查s2指向的字符串大小是否真的适合s1指向的数组。如果s2长于s1的数组长度，那么结果是未定义的（因为strcpy函数会一直复制到第一个空字符为止，所以它会越过s1的边界继续复制）。

### 13.5.2 strlen函数

字符串长度函数的圆形如下：`size_t strlen(const char* s);`

```C
size_t strlen(const char* s)
{
    size_t len = 0;
    for (; *s != '\0'; ++len, ++s);
    return len;
}
```

### 13.5.3 strcat函数

字符串拼接函数的原型如下：`char* strcat(char* s1, const char* s2);`

```C
char* strcat(char* s1, const char* s2)
{
    char* curr_pos = s1;
    while (*curr_pos != '\0') ++curr_pos;
    while (*s2 != '\0') {
        *curr_pos = *s2;
        ++curr_pos;
        ++s2;
    }
    ++curr_pos;
    *curr_pos = '\0';
    return s1;
}
```

如果s1指向的数组不足以容纳拼接后的字符串，那么结果是不可预测的。

### 13.5.4 strcmp函数

strcmp函数比较字符串s1和s2，然后根据s1是小于、等于或者大于s2，返回一个小于，等于或者大于0的值。

## 13.6 字符串惯用法

## 13.7 字符串数组

