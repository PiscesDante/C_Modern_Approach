# 第22章 输入输出

本章一章都是要讨论 `<stdio.h>` 这个头文件，输入输出函数的最主要函数库。

## 22.1 流

**流（ stream ）** 表示 **任意输入的源或任意输出的目的地** 。许多小型程序都是通过一个流（通常是键盘或者网络）获得全部的输入，并且通过另一个流（通常是屏幕）写出全部的输出。

请记住一点： **`<stdio.h>`中的许多函数可以处理各种形式的流，而不仅仅可以处理表示文件的流** 。

### 22.1.1 文件指针

C 程序中对流的访问是通过文件指针实现的。此指针的类型为 `FILE*` 。用文件指针表示的特定流具有标准的名字。如果需要，还可以声明另外一些文件指针。

### 22.1.2 标准流和重定向

`<stdio.h>` 提供了 3 个 **标准流对象** 。这 3 个标准流可以直接使用 —— 不需要声明，打开或者关闭它们：

* `stdin`（标准输入）：键盘；
* `stdout`（标准输出）：屏幕；
* `stderr`（标准错误）：屏幕；

前面章节使用的比如 `printf` 函数都是通过 `stdin` 获得输入，并且使用 `stdout` 进行输出。默认情况下，`stdin` 表示键盘，而 `stdout` 和 `stderr` 表示屏幕。许多操作系统允许通过 **重定向** 来改变这些默认设定。

通常我们 **可以强制程序从文件而不是从键盘获得输入** ，方法是 **在命令行中放上文件的名字，并在前面加上 `<` 字符** ：

```Shell
./demo < in.dat
```

这种方法称为 **输入重定向** ，它本质上是使 `stdin` 流表示「文件」而非「键盘」。重定向的一个特性是： **程序 `demo` 不会意识到正在从文件 `in.dat` 读取数据，它会认为从 `stdin` 获得的任何数据都是从键盘录入的** 。

输出重定向也是类似的。对 `stdout` 流的重定向通常是通过在命令行中放置文件名，并在前面加上字符 `>` 实现的：

```Shell
./demo > out.dat
```

现在将所有写入 `stdout` 的数据都将进入 `out.dat` 文件中了，而不是出现在屏幕上。我们还可以把输出重定向和输入重定向结合使用：

```Shell
./demo < in.dat > out.dat
```

### 22.1.3 文本文件与二进制文件

`<stdio.h>` 支持两种类型的文件：**文本文件** 和 **二进制文件** 。

* 在 **文本文件（Text File）** 中，字节表示字符，这使人们可以检查或者编辑文件（ `txt` 文件就是文本文件 ）。
* 在 **二进制文件（Binary File）** 中，字节不一定表示字符（ `exe` 文件就是二进制文件 ）。

文本文件具有两种二进制文件没有的特性：

* **文本文件分为若干行** ：文本文件的每一行通常以一两个特殊字符结尾，特殊字符的选择和操作系统有关 。
* **文本文件可以包含一个特殊的「文件末尾（ `EOF` ）」标记** 。

编写用来读写文件的程序时，需要考虑文件是文本文件还是二进制文件。

## 22.2 文件操作

简单性是输入输出重定向的魅力之一，不需要打开文件、关闭文件或者执行其他操作。但是限制较多。

### 22.2.1 打开文件

```C++
FILE* fopen(const char* restrict filename, const char* restrict mode);
```

如果要把文件用作流，打开时需要调用 `fopen` 函数。 `fopen` 函数的第一个参数是 **<u>文件全名字符串</u>** ，这里的文件名要包含文件的位置信息（即必须带有路径）。第二个参数是 **<u>操作模式字符串</u>** ，它用来指定打算对文件执行的操作。

`restrict` 关键字隶属于 C99 ，**表明 `filename` 和 `mode` 所指向的字符串的内存单元「不共享」** 。

`fopen` 函数返回一个文件指针，类型是 `FILE*` 。程序可以把该指针存储在一个变量中，稍后在需要对文件进行操作时使用：

`FILE* fp = fopen("in.dat", "r");`

**当文件无法被打开时， `fopen` 函数返回空指针（ `NULL` ）** 。所以不要假设文件可以打开，每次都要测试 `fopen` 函数的返回值是否为 `NULL` 以确保不是空指针。

### 22.2.2 模式

给 `fopen` 函数传递哪种模式字符串不仅依赖于将要采取的操作，还取决于文件的数据形式。

### 22.2.3 关闭文件

```C++
int fclose(FILE* filestream);
```

`fclose` 函数允许程序关闭不再使用的文件。 `fclose` 函数的参数必须是文件指针。 **如果成功关闭了文件，函数返回 `0` ；否则将会返回错误代码 `EOF` ，这个代码定义在 `<stdio.h>` 中，本质上是一个宏** 。

## 22.3 格式化的输入输出

### 22.3.1 `...printf` 函数

```C++
int fprintf(FILE* file_ptr, const char* format, ...);
int printf(const char* format, ...);
```

两个函数的返回值就是 **写入的字符数** ，若出错则返回一个 **负值** 。

`fprintf` 函数和 `printf` 函数 **唯一的不同** 就是：**<u>`printf` 函数始终向 `stdout` 写入内容，而 `fprintf` 函数则向它第一个参数，文件指针指向的文件中写入内容</u>** ：

```C++
printf("Total: %d\n", total); // writes to stdout
fprintf(file_ptr, "Total: %d", total); // writes to file_ptr's file
```

### 22.3.5 `...scanf` 函数

```C++
int fscanf(FILE* file_ptr, const char* format, ...);
int scanf(const char* format, ...);
```

`fscanf` 函数和 `scanf` 函数从输入流中读取数据，并且使用格式串来指明输入的格式。格式串的后边可以跟有任意数量的指针作为额外的实际参数。

`scanf` 函数始终从输入流 `stdin` 中读入数据，而 `fscanf` 函数则从它的第一个参数所指定的流中读入内容：

```C++
scanf("%d %d", &x, &y); // 从键盘上读取
fscanf(file_ptr, "%d %d", &x, &y); // 从 file_ptr 指向的文件中读取
```

如果发生输入失败或者匹配失败，那么 `...scanf` 函数会提前返回。如果在读入任何数据项之前发生输入失败，那么会返回 `EOF` 。

在 C 程序中测试 `scanf` 函数的返回值的循环很普遍。例如，下列循环逐个读取一串整数，在首个遇到问题的符号处停止：

```C++
while (scanf("%d", &i) == 1) {
    ...
}
```