# 第1章 C语言概述

## 1.1 C语言的历史

### 1.1.1 起源

### 1.1.2 标准化

### 1.1.3 基于C语言

* C++：包括了所有C的特性，但增加了类和其他特性以支持面向对象编程。
* Java：是基于C++的，所以也继承了C的许多特性。
* C#：是由C++和Java发展起来的一种较新的语言。
* Perl：最初是一种非常简单的脚本语言，在发展过程中采用了C的许多特性。

## 1.2 C语言的优缺点

* C语言是一种底层语言。C语言提供了很多机器级概念的访问，也提供了与计算机内置指令协调的操作。
* C语言是一种小型语言。C语言很大程度上要依赖标准库。
* C语言是一种包容性的语言。

### 1.2.1 C语言的优点

* 高效。发明C语言就是为了编写那些以往由汇编语言编写的应用程序。
* 可移植。
* 功能强大。
* 灵活。
* 标准库。
* 与UNIX系统集成。

### 1.2.2 C语言的缺点

* C程序更容易隐藏错误。
* C程序可能会难以被人阅读和理解。
* C程序可能会难以修改。

### 1.2.3 高效的使用C语言

* 学习如何避免C语言的缺陷。看到书中感叹号的部分就是C语言的语言缺陷，在实际应用中应当避开。
* 使用工具软件使程序更加可靠。
* 利用现有的代码库。不要重复造轮子。
* 采用一套切合实际的编码规范。精心选择的规范可以使程序更加统一。
* 避免投机取巧和极度复杂的代码。
* 紧贴标准，如果不是确实有必要，最好避免使用非标准库特性。

# 第2章 C语言基本概念

主要内容有**预处理指令**、**函数**、**变量**和**语句**。程序需要**编译和链接**。**变量**是用来**存储程序执行过程中可能会发生改变的数据的**。**常量**是**存储程序执行过程中不会发生改变的数据**。

## 2.1 编写一个简单的C程序

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    printf("To C, or not to C: that is the question.\n");
    return 0;
}
```

第一行是必不可少的。它包含进来了标准库的输入输出相关信息。程序的可执行代码都在主函数`main`中。`printf`函数来自标准输入输出库`<stdio.h>`。最后一句表明程序终止时会向操作系统返回`0`。

### 2.1.1 编译和链接

把C语言程序转换为机器可以执行的形式需要以下三个步骤：

* **预处理**：首先程序会被交给**预处理器**（preprocessor）。预处理器执行以`#`开头的命令（通常称为指令）。预处理器有点类似于编辑器，它可以给程序添加内容，也可以对程序进行修改。
* **编译**：修改后的程序被交给**编译器**（compiler）。编译器会把程序翻译成机器指令。但现在程序还是不可以运行的。
* **链接**：**链接器**（linker）把由编译器产生的目标代码和所需的其他附加代码整合在一起，这样才产生了可执行的程序。

### 2.1.2 集成开发环境

集成开发环境是一个软件包，我们可以在其中编辑、编译、链接、执行甚至调试程序。

## 2.2 简单程序的一般形式

简单的C程序一般有如下形式：

```C
指令

int main(int argc, char const *argv[])
{
    语句
}
```

C语言程序依赖三个关键的语言特性：

* **指令**：在编译前修改程序的编辑命令。
* **函数**：被命名的可执行代码块，如`main`函数。
* **语句**：程序运行时执行的命令。

### 2.2.1 指令

预处理器会首先对指令进行编辑。我们把**预处理器执行的命令称为指令**。

**所有的指令都是以字符`#`开始的**。这个字符可以把C程序中的指令和其他代码区分开来。**指令默认只占一行，每条指令的结尾没有分号或者其他特殊标记**。记住，是**<u>没有</u>**分号，**<u>任何指令都没有分号结尾</u>**。

### 2.2.2 函数

函数类似于其他变成语言中的“过程”。它们是用来构建程序的构件块。**C程序就是函数的集合。**

函数分为两大类：

* 程序员自己编写的函数。
* 作为C语言实现的一部分提供的函数。也就是库函数。

虽然一个C程序可以包含多个函数，**但是`main`函数是必须有的**。`main`函数是非常特殊的：**在执行程序时系统会自动地调用`main`函数**。

### 2.2.3 语句

语句就是程序运行时执行的命令。比方说上述程序中使用到的返回语句和函数调用语句。函数调用语句的作用就是分派给一个函数它要执行的任务。

**C语言规定每条语句都必须以分号结尾**，因为语句可以连续占用多行。**指令只占一行，因此不需要使用分号结尾**。

### 2.2.4 显示字符串

目前为止我们只使用了`printf`函数显示了一条**字符串字面量——用一对引号包围的一系列字符**。

## 2.3 注释

每一个程序都应该包含识别信息，C语言把这类信息放在注释中。符号`/*`标记注释的开始，而符号`*/`标记注释的结束。注释符号不能嵌套。但可以占据多行。

建议的两个注释方式：

```C
/*****************************
 * Name: pun.c
 * Purpose: Prints a bad pun    块注释
 * Author: K. N. King
 *****************************/

/* Beginning of main program 单行注释 */

// 新单行注释：C99
```

**`//`是C99提供的另一种类型的注释，这种方法只作用于一行**，所以不会出现未终止的注释符号意外吞噬部分程序的情况。

## 2.4 变量和赋值

### 2.4.1 类型

**每一个变量必须有一个类型**。<u>类型用来说明变量所存储的数据的种类</u>。类型会影响变量的存储方式以及允许对变量进行的操作，所以选择合适的类型是非常关键的。数值型变量的类型决定了变量所能存储的最大值和最小值，同时也决定了是否允许在小数点后出现数字。

`float`型变量所存储的数值往往**只是实际数值的一个近似值**：**`int` is not integer, `float` is not real**.

### 2.4.2 声明

在使用变量之前必须对其进行声明（为编译器所做的描述）。为了声明变量，首先要指定变量的类型，然后说明变量的名字。注意**每一条完整的声明语句都要以分号结尾**。

在`main`函数的第一个模版中并没有包含声明。**但`main`函数包含声明时，必须把声明放置在语句之前**：

```C
int main(int argc, char const *argv[])
{
    声明块
    
    语句块
    return 0;
}
```

这里书写格式的建议是：**在声明和语句之间留出一个空行。**

**C99中，声明可以不在语句之前**。但是为了和以前的编译器兼容，暂时不采用这一规则。但是C++和Java程序中在使用时才声明变量的情况很常见。

### 2.4.3 赋值

变量通过赋值的方式获得值。字面量都是常量。**变量在赋值或者以其他方式使用之前必须先声明**：

```C
int height;
height = 8;
```

当我们把一个包含小数点的常量赋值给`float`类型的变量时，**<u>最好在该常量的后面加一个字母`f`</u>**：`float height = 3.14f;`。不加可能会引发编译器的警告。

混合类型赋值是可以的，但是不一定安全，比方说**把浮点型赋给整型会发生“截断”效应，即<u>编译器丢弃小数部分</u>**。

### 2.4.4 显示变量的值

占位符`%f`默认情况下会显示小数点的后6位数字。

### 2.4.5 初始化

当程序开始执行时，某些变量（全局变量）会被自动的设置为`0`，而大多数变量则不会。**没有默认值并且尚未在程序中被赋值的局部变量是未初始化的**。试图访问未初始化的变量是未定义的行为。**可以在声明变量的同时初始化变量**。

### 2.4.6 显示表达式的值

`printf`的功能不仅局限于显示变量中存储的数，它可以显示任意数值表达式的值。

C语言的一个通用原则：**在任何需要数值的地方，都可以使用具有相同类型的表达式。**

## 2.5 读入输入

为了获取输入，就要用到`scanf`函数。它是C函数库中与`printf`函数相对应的函数。`scanf`中的字母`f`和`printf`中的字母`f`含义相同，都是表示“**格式化**”的意思。`scanf`函数和`printf`函数都需要使用**格式串**来指定输入或者输出的数据形式。**`scanf`函数需要知道将获得的输入数据的格式，而`printf`函数需要知道输出数据的显示格式。**

## 2.6 定义常量的名字

采用宏定义的特性来给常量命名：`#define INCHES_PER_POUND 166`。

这里使用的还是预处理指令，类似于前面的`#include`，行尾也没有分号。

**当宏定义包含运算符时，这个包含运算符的表达式必须使用括号括起来。**

注意，**宏的名字只使用大写字母**。这个规范已经几十年，希望读者不要打破。

## 2.7 标识符

**变量、函数、宏和其他实体的名字叫做标识符**。标识符可以含有字母、数字和下划线，但是**必须以字母或者下划线开头**。

C语言的标识符是区分大小写的。

命名风格最好使用下划线方法，并且坚持一种风格。

C语言对标识符的最大长度没有限制，所以不必担心使用较长的描述性名字。

#### 关键字

## 2.8 C程序的书写规范

我们可以把C程序看成一连串的**记号**（token），即许多在不改变意思的基础上无法再分割的字符组。标识符和关键字都是记号。

添加足够多的空格和空行可以使程序更便于阅读和理解。这一规则对于程序布局有如下积极意义：

* 语句可以分开放在任意多行内。
* 记号间的空格使我们更容易区分记号，通常会在每个运算符的前后都放上一个空格。
* 缩进有助于识别程序的嵌套。
* 空行可以把程序划分成逻辑单元。

# 第3章 格式化输入输出

## 3.1 printf函数

**`printf`函数被设计用来显示格式串的内容，并且再该串中的指定位置插入可能的值**。调用`printf`函数时必须提供**格式串**，格式串后面的参数是需要在显示时插入到该串中的值。

格式串包含普通字符和转换说明符，其中转换说明符以字符`%`开头。转换说明是用来表示打印过程中待填充值的占位符。跟随在字符`%`后边的信息指定了**把数值从内部形式（二进制）转换成打印形式（字符）的方法**。例如`%d`指定`printf`函数把`int`类型的值从二进制形式转换成十进制数字组成的字符串。

C语言的编译器不会检测格式串中转换说明的数量是否和输出项的数量相匹配。如果变量比占位符多，则从左到右按顺序打印并且**抛弃多余的变量**。**<u>如果变量少于占位符，则出现未定义的行为</u>**。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int x = 10;
    float y = 3.14f;
    printf("%d\n", x, y); // 10
    printf("%d, %f\n", x); // 10, 0.000000 注意这里是未定义行为
    return 0;
}
```

### 3.1.1 转换说明

以格式`%m.pX`来说明：

* **最小字段宽度（输出的数字占几位）**（`m`）：`m`指定了要显示的最少字符数量。
* **精度（保留的小数位数）**（`p`）：含义难以描述，因为精度依赖于转换说明符`X`的选择。

仔细辨认一下转换说明：

* `%d`：以十进制的方式显示变量。
* `%5d`：以十进制的形式显示变量，并且至少占用5个字符的空间。即如果该数字没有五位，那么就在后续位置添加上足够数量的空格。这种方法是左对齐的。记忆：**<u>正数的最小字段宽度表示左对齐（正左负右）</u>**。
* `%-5d`：以十进制的方式显示变量，并且要在数字的左边添加上足够多的空格使其至少占用5个位置，也就是**右对齐**的。

### 3.1.2 转义序列

格式串中的代码`\n`称为转义序列。转义序列使字符串包含了一些特殊字符而不会使编译器引发问题，这些字符包括非打印的（控制）字符和对编译器有特殊含义的字符。后面会提供完整的转义序列。

## 3.2 scanf函数

`scanf`函数根据特定的格式读取输入。`scanf`的格式串也可以包含普通字符和转换说明符两部分。

使用`scanf`函数时，**程序员必须检查转换说明的数量是否与输入变量的数量相匹配，并且检查每个转换是否适合相对应的变量**。另一个陷阱与符号`&`有关，通常把符号`&`放在`scanf`函数调用中每个变量的前面。因为C语言中的参数传递方式只有值传递，**所以只有地址才能让`scanf`函数知道从输入中读取的数据存储在什么地方**。

如果`scanf`函数的`&`符号丢失，将会产生不可预知且可能是毁灭性的结果。**忽略`&`符号是极为常见的错误，一定要小心。**

许多专业的C程序员会避免使用`scanf`函数，而是采用字符格式读取所有数据，然后把它们转换成数值形式。

### 3.2.1 scanf函数的工作方法

**`scanf`函数本质上是一种“模式匹配”函数，试图把输入的字符组与转换说明相匹配。**

像`printf`函数一样，**`scanf`函数是由格式字符串控制的**。调用时，`scanf`函数**从左边开始**处理字符串中的信息。对于格式串中的每一个转换说明，`scanf`函数从输入的数据中定位适当类型的项，并且在必要时跳过空格。

然后，`scanf`函数读入数据项，并且在**遇到不可能属于此项的字符时停止**。如果读入数据成功，那么`scanf`函数会继续处理格式串的剩余部分；**如果某一项不能成功读入，那么`scanf`函数将不再查看格式串的剩余部分而立即返回**。

在寻找数据的起始位置时，**`scanf`函数会忽略空白字符**。

在要求读入整数时，`scanf`函数首先寻找正号或者负号，然后读取数字**直到读到一个非数字时才停止**。当要求读入浮点数时，`scanf`函数会寻找一个正号或者负号，随后是一串数字（可能含有小数点），再后是一个指数（可选）。指数由字母`e`（或者字母`E`）、可选的符号和一个或者多个数字构成。

### 3.2.2 格式串中的普通字符

处理格式串中的普通字符时，`scanf`函数采取的动作依赖于这个字符是否为空白字符。

* **空白字符**：**当在格式串中遇到一个或者连续多个空白字符时，`scanf`函数从输入中重复读取空白字符直到遇到一个非空白字符**。格式串中的空白字符的数量无关紧要，**<u>格式串中的一个空白字符可以与输入中任意数量的空白字符匹配</u>**。
* **其他字符**：当格式串中遇到非空白字符，`scanf`函数将把它与下一个输入字符进行比较。如果两个字符相匹配，那么`scanf`会放弃输入字符而继续处理格式串。如果两个字符不匹配，**<u>那么`scanf`函数会把不匹配的字符放回输入中，然后异常退出</u>**。

### 3.2.3 易混淆的printf函数和scanf函数

`scanf`函数首先寻找输入中的整数，把这个整数存入变量`i中`；然后，`scanf`函数将试图把逗号与下一个输入字符相匹配，如果下一个输入的字符是空格而不是逗号，那么`scanf`函数将终止操作，而不再读取变量`j`的值。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int x = 10;
    char c = 'A';
    printf("%d %c\n", x, c); // 10 A
    scanf("%d", &x);         // 输入32R 这里只读取32存入变量，scanf函数中止读取
    printf("Hello World\n"); // Hello World
    scanf("%c", &c);         // 这里读取R
    printf("%d %c\n", x, c); // 32 R
    return 0;
}
```

# 第4章 表达式

表达式的定义：**如何计算值的公式**。最简单的表达式是变量和常量。

## 4.1 算术运算符

算术运算符：包括C语言在内的许多编程语言中都广泛应用的一种运算符，这类运算符可以执行加法、减法、乘法和除法。

加法类运算符和乘法类运算符都属于二元运算符，因为它们需要两个操作数。

除法运算符和取余运算符需要注意以下几点：

* 除法运算符可能产生意外的结果。**当两个操作数都是整数时，除法运算符会丢掉小数部分来截取结果，这个现象叫做“截断”。**
* **取余运算符要求操作数是整数**。如果两个操作数中有一个不是整数，程序将无法编译通过。
* 把零作为这两个操作符的右操作符是未定义的行为。
* 当负数作用于这两个操作符时，结果也是未定义的。但是C99中**除法的结果总是向零截取**。

#### 运算符的优先级和结合性

算术运算符的相对优先级如下：

* 最高优先级：`+`（一元）、`-`（一元）、`*`、`/`、`%`
* 最低优先级：`+`（二元）、`-`（二元）

当表达式包含两个或者更多相同优先级的运算符时，仅有运算符优先级的规则是不够的。这种情况下，运算符的结合性开始发挥作用。如果**运算符是从左向右结合的，那么称这种运算符是左结合的**。**二元算术运算符都是左结合的**。

如果运算符是从右向左结合的，那么称这种运算符是右结合的。一元运算符都是右结合的。

## 4.2 赋值运算符

### 4.2.1 简单赋值

表达式`v = e`的赋值效果是求出表达式`e`的值，并且把该值复制给`v`。

在许多变成语言中，赋值是语句；**<u>然而在C语言中，赋值是运算符</u>**。**赋值操作产生结果，这就如同两个数相加产生结果一样**。**<u>赋值表达式`v = e`的值就是赋值运算后`v`的值</u>**。

简单赋值运算符是第一个已知的有**<u>副作用</u>**的运算符，它改变了运算符的左操作数。对表达式`i = 0`求值产生的结果为`0`，并（作为副作用）把`0`赋值给`i`。

**副作用**：<u>当一个表达式或者函数除了返回值之外还对外部的状态造成了影响，那么就说这个函数或者表达式具有副作用</u>。

既然赋值是运算符，那么就可以串联赋值：`i = j = k = 10;`，**赋值运算符是右结合的**。

```C
// 例子：
int i = 1;           // 1
int j = 10;          // 10
int k = 1 + (j = i); // 先将i赋值给j，所以现在i，j，k分别为1，1，2
```

### 4.2.2 左值

赋值运算符要求它的左操作数必须是左值。**左值**表示**<u>存储在计算机内的对象</u>**，而不是常量或者计算的结果。

### 4.2.3 复合赋值

**复合运算符有着和赋值运算符一样的特性。它们都是右结合的**。所以语句`i += j += k;`等价于`i += (j += k);`。

## 4.3 自增运算符和自减运算符

C语言允许使用`++`（自增）和`--`（自减）运算符来计算。这两个符号也有**副作用：它们会改变操作数的值**。

计算表达式`++i`的表达式计算结果是`i + 1`，而副作用的效果是自增`i`。

需要记住的是：**<u>后缀运算符比一元的正负号优先级高，而且都是左结合的。前缀运算符与一元正负优先级相同。且都是右结合的。</u>**

## 4.4 表达式求值

#### 子表达式的求值顺序

如果两个相同优先级的子表达式中有对方的运算子对象，那么这个整体表达式的求值很可能是未定义的。

#### 未定义行为

程序中出现未定义的行为时，后果是不可预料的。不同的编译器给出的编译结果可能是不同的，且有可能根本无法通过编译。应该彻底避免未定义行为的发生。

## 4.5 表达式语句

任何表达式都可以作为语句。即**无论表达式是什么类型，计算什么结果，都可以通过在后面添加分号将其转换为语句**。通常的情况是**丢掉表达式的返回值，然后执行副作用**，类似`1 + 1;`的表达式没有任何副作用时，就什么都不会发生。

# 第5章 选择语句

C语言的三大类语句：

* **选择语句**：`if`语句和`switch`语句允许程序在一组可选项中选择一条特定的执行路径。
* **重复语句**：`while`语句，`do`语句和`for`语句支持重复循环操作。
* **跳转语句**：`break`语句，`continue`语句和`goto`语句导致无条件的跳转到程序中的某个位置（`return`语句也属于此类）。

其他两类语句：

* **复合语句**：几条语句组成的一条语句。
* **空语句**：不执行任何操作。

## 5.1 逻辑表达式

C语言中，逻辑表达式会产生**整数**（C语言中布尔类型不是内置类型）：`0`（假）或`1`（真）。因为在C语言中没有内置的布尔类型，如果要使用布尔类型，必须使用C99的`<stdbool.h>`头文件。

### 5.1.1 关系运算符

**关系运算符的优先级低于算术运算符**。关系运算符是左结合的。

### 5.1.2 判等运算符

和关系运算符一样，判等运算符也是左结合的，也是产生`0`或者`1`作为结果。然而判等运算的优先级低于关系运算符。

### 5.1.3 逻辑运算符

逻辑运算符所产生的结果是`0`或者`1`。操作数的值经常是`0`或者`1`，但这不是必须的。**<u>逻辑运算符将任何非零值操作数作为真值来处理，同时将任何零值作为假值来处理</u>**。

与运算符和或运算符都采用“**短路**”计算。也就是说，**这些运算符首先计算出左操作数的值，然后计算右操作数；如果表达式的值可以仅由左操作数的值推导出来，那么将不再计算右操作数的值并直接返回结果**。

## 5.2 if语句

`if (表达式) 语句`

表达式两边的圆括号是必需的，是if语句的必要组成部分。

**执行if语句时，先计算圆括号内表达式的值。如果表达式的值非零，那么接着执行圆括号后边的语句。**

### 5.2.1 复合语句

`{ 若干条语句 }`

每条单独语句还是以分号结尾的，但是复合语句本身不是。复合语句被括在一个大括号里。

### 5.2.2 else语句

即便在不必要的情况下也使用花括号有两个好处：

* 由于很容易添加更多的语句到任何`if`或者`else`子句中，程序变得更加容易修改。
* 这样做可以在向`if`或者`else`子句中添加语句时避免由于忘记使用花括号而导致错误。

### 5.2.3 级联式if语句

级联式if语句的功能就是**一旦查到某一个条件为真就立即停止，然后执行相应的语句块**。

### 5.2.4 “悬空else”的问题

当if语句嵌套时，千万当心“悬空`else`”问题。就是**逻辑上应当匹配的`else`语句块和编译器认定的`else`语句块有出入**。

```C
if (y != 0) // 1
    if (x != 0) // 2
        result = x / y;
else // 这个else实际上属于2，而缩进上看得出程序员像将其设置为1的else
    printf("Error: y is equal to 0\n");
```

C语言的配对规则是：**<u>`else`子句应该属于离它最近的且还未和其他`else`匹配的`if`语句</u>**。

为了不产生歧义，必须严格加上花括号来控制选择流的匹配。

### 5.2.5 条件表达式

**条件运算符**由符号`?`和符号`:`组成，两个符号必须按照如下格式使用：`(表达式1) ? 表达式2 : 表达式3`

表达式1，2，3可以是任何类型的表达式，按照上述方案**组成的表达式称为条件表达式**。条件运算符是C运算符中唯一一个要求三个操作数的运算符。因此，条件运算符也是三元运算符。

条件表达式的读法：**<u>如果`表达式1`成立，那么`表达式2`，否则`表达式3`</u>**。

条件表达式求值的步骤是：**首先计算`表达式1`的值，如果此值不为零，那么计算`表达式2`的值，并且计算出来的值就是整个条件表达式的值；如果`表达式1`为零，那么`表达式3`的值是整个条件表达式的值。**

除了赋值运算符，条件运算符的优先级低于其他所有运算符。所以要将`表达式1`使用括号括起来。

条件表达式使程序更短小但是也更难以阅读，所以最好避免使用。

### 5.2.6 C89中的布尔值

C89的程序员通常使用`TRUE`和`FALSE`定义宏：

```C
#define TRUE 1
#define FALSE 0

int flag = TRUE;
flag = FALSE;
```

当然，为了发扬这一思想，甚至可以重新定义一个类型：

```C
#define BOOL int
#define TRUE 1
#define FALSE 0

BOOL flag = TRUE;
// ...
```

### 5.2.7 C99中的布尔值

C99提供了`_Bool`类型，所以在C99中，布尔类型的变量可以声明为：

```C
_Bool flag;
```

`_Bool`是无符号的整数类型，所以其本质就是整形变量；但是和一般的整形不同，该类型只能赋值为`0`或`1`。

除了上述类型，C99还提供了一个新的头文件`<stdbool.h>`，如果程序包含了这个文件，就可以直接这样写：

```C
#include <stdbool.h> // bool true false 后面两个是宏

int main(int argc, char const* argv[]) {
    bool flag;
    // ...
}
```

建议最好使用`<stdbbool.h>`头文件，这样可以和C++的规范统一起来。

## 5.3 switch语句

C语言提供了`switch`语句作为级联式`if`语句的替换：

```C
switch (grade) {
    case 4 : printf("Excellent\n"); break;
    case 3 : printf("Good\n"); break;
    case 2 : printf("Average\n"); break;
    case 1 : printf("Poor\n"); break;
    case 0 : printf("Fail\n"); break;
    default : printf("Error: Illegal Grade\n"); break;
}
```

`default`分支是当且仅当`grade`的值和任何选项都不匹配的执行选项。

**`switch`语句往往比`if`语句执行速度更快**，特别是在有许多情况要判断的情况下。

```C
switch (控制表达式) {
    case 常量表达式 : 语句 // 这里必须是常量表达式
    default : 语句
}
```

* **控制表达式**：`switch`后边必须跟着由圆括号括起来的<u>整型表达式</u>。这里**C语言将字符当成整数来处理**，因此在`switch`语句中可以对字符进行判定。这里**不能使用浮点数和字符串**。
* **分支标号**：每个分支的开头都有一个标号，常量表达式很像普通的表达式，只是不能包含变量和函数调用。
* **语句**：每个分支标号的后面可以跟任意数量的语句。这里**不需要用花括号将语句括起来**。每组语句的最后一条通常是`break`语句。

C语言**不允许有重复的分支标号**，但是对于分支的顺序没有要求，特别是`default`分支**不一定**要放在最后。

`case`后面只可以跟随一个常量表达式。但是多个分支标号可以共享一套语句。

```C
switch (grade) {
    case 4 :
    case 3 :
    case 2 :
    case 1 : printf("Pass\n"); break; // 1，2，3，4共享这两个语句
    case 0 : printf("Fail\n"); break;
    default : printf("Error: Illegal Grade\n"); break;
}
```

`switch`语句不要求一定要有`default`分支。

#### break语句的作用

需要`break`语句是由于`switch`语句实际上是一种“**基于计算的跳转**”。**对控制表达式求值时，控制会跳转到与`switch`表达式值相匹配的分支标号处。分支标号只是一个说明`switch`内部位置的标记。在执行完分支中的最后一条语句后，程序控制“向下跳转”到下一个分支的第一条语句上，但是这时会忽略下一个分支的标号**。如果没有`break`语句，控制将会从一个分支继续到下一个分支。

```C
/*********************************************
 * 执行这个程序基本上就可以理解switch语句的工作原理 *
 *********************************************/
#include <iostream>

void down_stairs(int k);

int main(int argc, char const *argv[])
{
    int flr;
    do {
        std::cout << "Enter the floor you are on right now: ";
        std::cin >> flr;
        down_stairs(flr);
    } while (flr >= 0 && flr <= 10);
    return 0;
}

void down_stairs(int k)
{ // 这里没有break语句
    switch (k) {
        case 10 : std::cout << "Now I am on the 10th floor." << std::endl;
        case 9 : std::cout << "Now I am on the 9th floor." << std::endl;
        case 8 : std::cout << "Now I am on the 8th floor." << std::endl;
        case 7 : std::cout << "Now I am on the 7th floor." << std::endl;
        case 6 : std::cout << "Now I am on the 6th floor." << std::endl;
        case 5 : std::cout << "Now I am on the 5th floor." << std::endl;
        case 4 : std::cout << "Now I am on the 4th floor." << std::endl;
        case 3 : std::cout << "Now I am on the 3rd floor." << std::endl;
        case 2 : std::cout << "Now I am on the 2ed floor." << std::endl;
        case 1 : std::cout << "Now I am on the 1st floor." << std::endl;
        case 0 : std::cout << "Now I am on the ground." << std::endl;
    }
}
```

# 第6章 循环

循环是重复执行其他语句（循环体）的一种语句。C语言中，每个循环都有一个**控制表达式**。**每次执行循环体（循环重复一次）时都要对控制表达式求值**。如果表达式为真（即值不为零），那么继续执行循环。

C语言提供了三种重复语句，即`while`语句，`do`语句和`for`语句。

`while`循环在循环体之前测试控制表达式；`do`循环在至少执行一次循环体之后测试控制表达式；`for`语句则非常适合那些递增或者递减计数变量的循环。

## 6.1 while语句

`while (控制表达式) { 循环体 }`

执行`while`语句时，首先**计算`控制表达式`的值**。如果**值不为零**（即真值），那么**执行`循环体`**，接着**再次判定`控制表达式`**。这个过程（先判定控制表达式，再执行循环体）持续直到控制表达式的值为假才停止。

#### 无限循环

如果`控制表达式`的值始终非零，`while`语句将无法中止。

## 6.2 do语句

`do`语句的本质就是`while`语句，只不过其控制表达式是在每次循环体执行完毕之后才进行判定的。

格式：`do { 循环体 } while (控制表达式);`

**必须给所有`do`语句都加上花括号**，这是因为没有花括号的`do`语句很容易被误认为是`while`语句。

## 6.3 for语句

`for`语句格式：`for (表达式1; 表达式2; 表达式3) { 语句 }`

等价的`while`循环：

```C
表达式1;
while (表达式2) {
    循环体
    表达式3;
}
```

**`表达式1`是循环开始执行前的初始化步骤，只执行一次；`表达式2`用来控制循环的终止（只要表达式2的值不为零，循环持续执行）；而`表达式3`是每次循环体执行完毕之后才执行的一个操作。**

### 6.3.1 for语句的惯用法

```C
for (i = 0; i < n; ++i) { ... } // 从0向上加到n-1
for (i = 1; i <= n; ++i) { ... } // 从1向上加到n
for (i = n - 1; i >= 0; --i) { ... } // 从n-1向下减到0
for (i = n; i > 0; --i) { ... } // 从n向下减到1
// 这里要当心循环次数差1的问题
```

### 6.3.2 在for语句中省略表达式

`for`语句允许省去任意数量（0到3）的表达式。

如果省略第二个表达式，那么它的默认值为真，因此语句不会以靠自身的机制停下来，必须借助`return`，`break`等语句。

### 6.3.3 C99中的for语句

在C99中，**`for`语句的第一个表达式可以替换为一个声明**，这一特性使得程序员可以声明一个只用于循环的的变量：

```C
for (int i = 0; i < n; ++i) { ... } // int i = 0方式为C99专属，循环变量i在循环外不可见
```

让`for`语句声明自己的循环控制变量通常是一个好办法：这样很方便且程序的可读性更强。

`for`语句语句可以声明多个变量，只要它们类型相同。

### 6.3.4 逗号运算符

`表达式1, 表达式2`

这里的`表达式1`和`表达式2`是两个任意的表达式。逗号表达式的计算要通过两步来实现：

1. **计算表达式1并且丢弃计算出来的值**。
2. **计算表达式2，把这个值作为整个表达式的值**。

**<u>这里对于表达式1的计算应该始终都会有副作用；如果没有，那么表达式1的存在是没有意义的。</u>**

提供**逗号运算符**是为了在C语言要求**只能有一个表达式的情况下可以使用两个或者多个表达式**。逗号运算符允许将两个表达式连接在一起构成一个表达式。逗号表达式的计算方式是**从左向右**计算。

## 6.4 退出循环

* **`continue`语句**：跳过某次迭代的部分内容，但是不会跳出整个循环。
* **`goto`语句**：允许程序从一条语句跳转到另一条语句。

### 6.4.1 break语句

对于退出点在循环体的中间而不是循环体之前或者之后的情况，`break`语句特别有用。

`break`语句把程序控制从包含该语句的最内层`while`、`do`、`for`或者`switch`语句中转移出来。**因此，当这些语句出现嵌套时，`break`语句只能跳出当前嵌套**。

### 6.4.2 continue语句

`break`语句是把程序控制转移到循环体末尾之后，而`continue`语句是把程序控制转移到循环体末尾之前。

`break`和`continue`的一个区别是：**`break`语句可以用于`switch`语句和循环，而`continue`只能用于循环**。

### 6.4.3 goto语句

**`goto`语句可以跳转到函数中任何有标号的语句处**。（C99中增加了一条限制：`goto`语句不可以用于绕过变成数组的声明。）

标号只是放置在语句开始处的标识符：`标识符 : 语句`

`goto`语句的自身格式如下：`goto : 标识符;`

**`goto`语句可以跳出多重循环嵌套的语句群**。

## 6.5 空语句

语句可以为空，就是除了末尾处的分号以外什么符号也没有。空语句的主要作用之一就是编写空的循环体。

# 第7章 基本类型

**<u>计算机处理的是数字而不是符号。</u>**

## 7.1 整数类型

C语言支持两种根本不同的数值类型：**整数类型**（整型）和**浮点类型**（浮点型）。整数类型的值是整数，而浮点类型的值则可能还有些小数部分。整数类型又分为两大类：**有符号类型**和**无符号类型**。

#### 有符号整数和无符号整数

有符号整数如果为正数或者零，那么最左边的位（符号位）为`0`；如果是负数，则符号位为`1`。不带符号位的整数称为无符号整数。**默认情况下，C语言中的整形变量都是有符号的，也就是说最左位保留符号位**。

C语言允许通过省略单词`int`来缩写整数类型的名字：

```C
unsigned short int => unsigned short
long int => long
```

整数类型的每一种所表示的取值范围都会根据机器的不同而不同，但是有两条所有编译器都必须遵守的原则：

* C标准要求`short`、`int`、`long`中的每一种类型都要覆盖一个确定的最小取值范围。
* 标准要求`int`类型不能比`short`类型短，`long`类型不能比`int`类型短。

确定整数类型范围的一种方法是检查`<limits.h>`头文件。

### 7.1.1 C99中的整数类型

C99提供了两个标准整数类型：`long long`和`unsigned long long`。这两个基本上不是特别常用。

### 7.1.2 整数常量

常量：在程序中以文本形式出现的数，而不是读、写或者计算出来的数。

* **十进制**：常量包含0 - 9中的数字，但是一定不能以0开头——15，255，32767
* **八进制**：常量只包含0 - 7中的数字，而且必须要以0开头——017，0377，077777
* **十六进制**：常量包含0 - 9中的数字和a - f中的字母，而且总是以0x开头——0xAF，0x14

**<u>八进制和十六进制只是数字的一种书写方式</u>，它们不会对数的实际存储方式产生影响**。任何时候都可以从一种书写方式切换到另一种书写方式。甚至可以混合使用：`15 + 025 + 0xAF`。八进制和十六进制往往用于底层程序的编写。

### 7.1.3 C99中的整数常量

### 7.1.4 整数溢出

对整数执行算术运算时，其结果有可能因为太大而无法表示。整数溢出时的行为要根据操作数是有符号还是无符号来确定。**有符号整数运算中发生溢出时，程序的行为是未定义的**。**无符号整数运算过程中发生溢出时，结果是有定义的：正确答案是对2的n次方取模，其中n是用于存储结果的位数**。类似于钟表的溢出，即12点之后指针会指向1点。

### 7.1.5 读写整数

* 读写**无符号整数**时，使用字母`u`、`o`或者`x`代替转换说明中的`d`。
* 读写**短整数**时，在`d`、`o`、`u`或者`x`前面加上字母`h`（`s`被字符串占用）。
* 读写**长整数**时，在`d`、`o`、`u`或者`x`前面加上字母`l`。
* 读写**长长整数**时，在`d`、`o`、`u`或者`x`前面加上字母`ll`。

切记：**<u>当有符号整数发生溢出时，结果是未定义的</u>**。

## 7.2 浮点类型

C语言提供了三种浮点类型，对应三种不同的浮点格式：

* `float`：单精度浮点数。
* `double`：双精度浮点数（默认情况）。
* `long double`：扩展精度浮点数。

`double`提供的精度对于绝大多数程序来说都够用了。`long double`支持极高的精度要求，很少会用到。

C99中，浮点类型分为两种：**浮点实类型**和**复数类型**。

### 7.2.1 浮点常量

浮点常量必须包含小数点或者指数；其中，指数指明了对前面的数进行缩放所需的10的幂次。**默认情况下，<u>浮点常量都以双精度的形式存储</u>**。当C语言编译器在程序中发现常量`57.0`时，它会安排数据以**双精度**的形式存储在内存中。这条规则通常不会引发任何问题。

### 7.2.2 读写浮点数

转换说明符`%e`，`%f`，`%g`用于读写单精度浮点数。读写`double`和`long double`类型的值所需的转换说明符略有不同。

* 读取`double`类型的值时，在`e`、`f`或者`g`前放置字母`l`：

  ```C
  double d;
  scanf("%lf", &d); // 读取double类型的，long float
  ```

* 读写`long double`类型的值时，在`e`、`f`或`g`前放置字母`L`：

  ```C
  long double ld;
  scanf("%Lf", &ld);
  printf("%Lf", ld);
  ```

## 7.3 字符类型

`char`类型就是字符类型。`char`类型的值可以根据计算机的不同而不同，因为不同的机器可能会有不同的字符集。

`char`类型的变量可以用任意单字符赋值：

```C
char ch;
ch = 'A'; // 字符常量需要用单引号括起来，而不是双引号。
```

### 7.3.1 字符操作

因为存在这样一个事实：**<u>C语言把字符当作小整数进行处理</u>**。因为**所有的字符都是以二进制的形式进行编码的**，而且无需花费太多的想象就可以将这些二进制的代码看成整数。

**字符常量**事实上是**<u>`int`类型</u>**而不是`char`类型。

可以像比较数那样对字符进行比较。诸如`'a' <= ch`这样的比较使用的是字符所对应的整数值，这些数值根据使用的字符集有所不同。

**字符拥有和数字相同的属性**，这一事实会带来一些好处。毕竟我们可以像遍历数字那样来遍历字母表。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    for (char ch = 'a'; ch <= 'z'; ++ch) // 如果这里将i声明为int打印出来的就是整数
        printf("%c ", ch); // a b c ...
    putchar('\n');
    return 0;
}
```

### 7.3.2 有符号字符和无符号字符

C语言标准允许使用单词`signed`和`unsigned`来修饰`char`类型。

### 7.3.3 算术类型

整数类型和浮点数类型统称算术类型。

* **整值类型**：字符数型（`char`），有符号整型，无符号整型，枚举类型。
* **浮点类型**：实数浮点类型，复数类型。

### 7.3.4 转义序列

**一些不可见的，非打印字符或者无法从键盘输入的字符被划分成为转义序列。**

转义序列一共有两种：

* 字符转义序列。
* 数字转义序列。

### 7.3.5 字符处理函数

使用`if`语句将小写字母转换为大写字母的方法：

```C
if ('a' <= ch && ch <= 'z') return ch - 'a' + 'A';
```

当然也可以使用C语言的`toupper`库函数：

```C
#include <ctype.h>
char up = toupper(ch);
```

### 7.3.6 用scanf和printf读写字符

转换说明符`%c`允许`scanf`函数和`printf`函数对单个字符进行读写：

```C
char ch;
scanf("%c", &ch); // 读一个字符
printf("%c", ch); // 打印一个字符
```

**在读入字符之前，`scanf`函数不会跳过空白字符**。如果下一个未读字符是空格，那么在前面的例子中，`scanf`函数返回后变量`ch`将包含一个空格。**为了强制`scanf`函数在读入字符前跳过空白字符，那么就需要在格式串中的转换说明`%c`前面加上一个空格**：

```C
scanf(" %c", &ch); // 这样空格就会直接匹配掉开始的所有空格字符
```

**`scanf`格式串中的空白意味着“跳过零个或者多个空白字符”**。

### 7.3.7 用getchar和putchar读写字符

`putchar`函数用于写单个字符：

```C
char ch;
putchar(ch); // 打印出ch的内容
```

每次调用`getchar`函数时，它会读入一个字符并且将其返回。为了保存这个字符，必须使用赋值操作将其存储到变量中：

```C
char ch;
ch = getchar(); // 从输入中获得一个字符然后存储在ch中
```

事实上，`getchar`函数返回的是一个**<u>`int`类型的值</u>**而不是`char`类型的值。如果一个变量用于存储`getchar`函数读取的字符，其类型设置为`int`而不是`char`也是可行的。和`scanf`函数一样，`getchar`函数也不会在读取字符时跳过空白字符。

执行程序时，**使用`getchar`函数和`putchar`函数可以节约时间。这两个函数执行速度快有两个原因**：

* 这两个函数比`scanf`和`printf`函数简单的多，因为后两者牵扯到格式化的问题。
* 为了额外的速度提升，通常`getchar`和`putchar`函数是作为宏来实现的。

因为`getchar`返回的是读入的字符，所以`getchar`函数可以应用在多种不同的C语言习惯用法中。

如果在同一个程序中混合使用`getchar`函数和`scanf`函数，请一定要注意：**`scanf`函数倾向于遗留下它扫描过但是未读取的字符（包括换行符）**：

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int i;
    char command;
    printf("Enter an integer: "); // 如果我们这里输入12A
    scanf("%d", &i);              // 这里scanf函数读取12，然后在A前面停下来
    printf("Enter a command: ");
    command = getchar(); // 这里getchar函数会直接从scanf函数剩下的部分，也就是A字符开始读
    printf("%d %c", i, command); // 输出
    // 最终程序的输出结果：Enter a command: 12 A
    return 0;
}
```

#### 程序：确定消息的长度

```C
/**************************************
 * Determines the length of a message *
 **************************************/

#include <stdio.h>

int main(int argc, char const *argv[])
{
    int counter;
    printf("Enter a message: ");
    for (counter = 0; getchar() != '\n'; ++counter);
    printf("Your message was %d character(s) long.\n", counter);
    return 0;
}

// Result:
// Enter a message: Brevity is the soul of wit.
// Your message was 27 character(s) long.
```

## 7.4 类型转换

为了让计算机执行算术运算，通常要求操作数有相同的大小（即位的数量相同），并且要求存储的方式也相同。**计算机可能将两个16位整数相加，但是不能直接将16位整数和32位整数相加**。

C语言允许在表达式中混合使用基本类型。在单个表达式中可以组合整数、浮点数，甚至是字符。当然，这种情况下C编译器可能需要生成一些指令将某些操作数转换成为不同的类型，使得硬件可以进行表达式计算。

因为编译器可以自动处理这些转换而无需程序员的介入，所以这类转换称为**隐式转换**。

C语言还允许程序员使用强制运算符执行**显式转换**。

#### 当发生下列情况时会进行隐式转换

* 当算术表达式或者逻辑表达式中操作数类型不相同时（常用算术转换）。
* 当运算符右侧表达式的类型和左侧变量的类型不匹配时。
* 当函数调用中的实参类型与其对应的形参类型不匹配时。
* 当`return`语句中的表达式的类型和函数返回值的类型不匹配时。

### 7.4.1 常用算术转换

常用的算术转换策略是**把操作数转换成<u>可以安全的适用于两个数值的“最狭小的”数据类型</u>**。

**<u>狭小</u>**的定义：<u>如果A类型要求的**存储位数**比B类型少，那么就说A类型比B类型狭小</u>。

为了统一操作数的类型，通常可以**将相对狭小的类型的操作数转换成另一个操作数的类型来实现**（这就是所谓的**提升**）。最常用的提升就是**整型提升**，**它把字符或短整数转换成`int`类型**。

#### 执行常用算术转换的规则可以划分成两种情况

* 任一操作数的类型是浮点类型的情况：`float => double => long double`。
* 两个操作数的类型都不是浮点类型的情况：`int => unsigned int => long int => unsigned long int`。

当把有符号操作数和无符号操作数组合时，**<u>会把有符号操作数“转换”为无符号的值</u>**！由于此类陷阱的存在，**所以最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用**。

### 7.4.2 赋值过程中的转换

常用算术转换不适用于赋值运算。C语言会遵循另一条简单的转换规则：**把赋值运算符右边的表达式转换成左边变量的类型**。如果变量的类型至少和表达式类型一样“宽”，那么就没有任何转换问题。

当把浮点数赋值给整形变量时，变量会**直接丢掉小数部分**，这种现象叫做“**截断**”。

**如果浮点常量被赋值给`float`类型的变量时，一定要在浮点常量尾部加上后缀`f`**。如果没有后缀，常量3.14将是`double`类型，可能会引起警告消息。

### 7.4.3 C99中的隐式转换

### 7.4.4 强制类型转换

C语言提供了强制类型转换。**强制转换**表达式的格式如下：`(类型名)表达式`。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    float val;
    float frac_part;
    val = 3.14f;
    frac_part = val - (int)val; // 0.14
    return 0;
}
```

C语言把`(类型名)`视为一元运算符。**一元运算符的优先级高于二元运算符**。

## 7.5 类型定义

一个更好的设置布尔类型的方法是利用所谓的类型定义的特性：

```C
typedef int Bool; // 这里注意，所定义的类型名要放在最后！！！
```

这时编译器将**把`Bool`类型看成是`int`类型的同义词**。

### 7.5.1 类型定义的优点

### 7.5.2 类型定义和可移植性

## 7.6 sizeof运算符

**<u>`sizeof`运算符允许程序存储指定类型值所需空间的大小</u>**：`sizeof(类型名)`。

`sizeof`运算符返回的值始终是一个**无符号的整数**，代表存储当前类型的值所需要的**<u>字节数</u>**。

`sizeof`运算符是一种特殊的运算符，因为编译器本身就可以确定`sizeof`表达式的值。

`sizeof`作为一元运算符的优先级要高于二元运算符。所以在**使用`sizeof`运算符时一定要始终加上圆括号**。

# 第8章 数组

目前为止我们所涉及的变量都是标量：**标量具有保存单一数据项的能力**。

C语言也支持聚合变量，这类变量可以存储一组的数据。C语言中一共有两种聚合类型：**数组**和**结构**。

## 8.1 一维数组

**<u>数组是含有多个数据值的数据结构，并且每个数据值具有相同的类型</u>**。这些数据值称为元素，可以根据元素在数组中的所处位置把它们一个个的选出来。

为了声明数组，需要指明数组元素的类型和数量。

```C
int arr[10]; // 声明数组arr有10个int类型的元素
```

数组元素可以是任何类型，数组的长度可以用任何**整数常量表达式**指定。因为程序以后可能需要调整数组的长度，**所以较好的方法是使用宏来定义数组的长度**：

```C
#define LEN 10
int arr[LEN];
```

### 8.1.1 数组下标

为了存取特定的数组元素，可以在写数组名的同事在后面加上一个用方括号包围的整数值，这种方法称为**对数组取下标**或者**对数组进行索引**。数组元素从`0`开始，所以长度为`n`的数组元素的索引范围是从`0 ~ n - 1`。

形如`a[i]`的表达式是左值，所以数组元素可以像普通变量一样使用：

```C
a[i] = 1;
printf("%d\n", a[5]);
++a[i];
```

如果数组包含`T`类型的元素，那么数组中的每个元素均视为`T`类型的变量。

注意：**这里在调用`scanf`函数读取数组元素时，就像对待普通变量一样，必须使用取地址符`&`**。

#### 程序：数列反向

```C
/*******************************
 * Reverse a series of numbers *
 *******************************/

#include <stdio.h>

#define LENGTH_OF_ARRAY 10

int main(int argc, char const *argv[])
{
    int arr[LENGTH_OF_ARRAY];
    int begin = 0;
    int end = 9;
    int temp = 0;
    printf("Enter %d numbers: ", LENGTH_OF_ARRAY);
    for (int i = 0; i < 10; ++i) scanf("%d", &arr[i]);
    while (begin < end) { // Reverse
        temp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = temp;
        begin += 1;
        end -= 1;
    }
    printf("In reverse order: ");
    for (int i = 0; i < 10; ++i) printf("%d ", arr[i]);
    printf("\n");
    return 0;
}

// output:
// Enter 10 numbers: 34 82 49 102 7 94 23 11 50 31
// In reverse order: 31 50 11 23 94 7 102 49 82 34
```

### 8.1.2 数组初始化

**数组初始化式**最常见的格式是**用一个大括号括起来的常量表达式列表**，常量表达式之间用**逗号**进行分隔：

```C
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 数组初始化式
```

**如果初始化式比数组短，那么数组中剩余的元素赋值为`0`**：

```C
int arr[5] = {1, 2, 3};
// initial value of this array is: 1, 2, 3, 0, 0
```

利用这个特性，可以很容易的把数组全初始化为`0`：

```C
int arr[10] = {0};
// initial value of this array is: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
```

注意**<u>初始化式完全为空是非法的</u>**，所以要在大括号内放上一个`0`。**<u>初始化式长度比数组长度大也是非法的</u>**！

在初始化的过程中，如果可以明确的给出初始化式，可以省略掉数的长度：

```C
int arr[] = {1, 2, 3, 4, 5};
// 数组的长度是5，编译器利用初始化式的长度来确定数组的大小
```

### 8.1.3  指定初始化式（C99）

C99中的指定初始化式可以用于解决这一问题。上面的例子可以使用指定初始化式：

```C
int arr[15] = {[2] = 29, [9] = 7, [14] = 48};
```

括号中的数字称为指示符，这样初始化的数组除了索引为2，9，14的元素以外全部为零。**指示符必须是整型常量表达式。**

#### 程序：检查数中重复出现的数字

```C
/****************************************
 * Check if there is any repeated digit *
 ****************************************/

#include <stdio.h>

#define LENGTH_OF_ARRAY 10

int main(int argc, char const *argv[])
{
    int digits[LENGTH_OF_ARRAY] = {0};
    printf("Enter a number: ");
    char ch;
    while ((ch = getchar()) != '\n') {
        digits[ch - '0'] += 1;
        if (digits[ch - '0'] > 1) {
            printf("Repeated digit.");
            return 0;
        }
    }
    printf("No repeated digit.");
    return 0;
}

// output:
// Enter a number: 28212
// Repeated digit.
// Enter a number: 9537
// No repeated digit.
```

### 8.1.4 对数组使用sizeof运算符

运算符`sizeof`可以确定**数组的大小**（**字节**数）。如果数组`a`有10个整数，那么`sizeof(a)`通常为40（32位的`int`有4个字节，一个字节8位）。

还可以使用`sizeof`来计算数组元素的大小。**用数组的大小除以数组元素的大小可以得到数组的长度**：`sizeof(a) / sizeof(a[0])`。

## 8.2 多维数组

数组可以有任意维数。该声明产生一个二维数组：`int mat[5][9];`。表示该二维数组有5行9列。

为了访问i行j列中的元素，需要写成`mat[i][j]`的形式。

虽然我们以表格的形式显示二维数组，但是实际上它们在计算机内存中不是这样存储的。C语言是按照**行主序**存储数组的：从第0行开始，接着第1行，依此类推。

C语言为存储多维数据提供了更加灵活的方法：指针数组。

### 8.2.1 多维数组初始化

通过嵌套一维初始化列表的方式可以产生二维数组的初始化式。

* 如果初始化式没有大到足以填满整个多维数组，那么把数组中剩余的元素赋值为0。
* 如果内层的列表没有大到足以填满数组的一行，那么把此行剩余的元素初始化为0。
* 甚至可以省略掉内层的花括号，因为一旦编译器发现数值足以填满一行，它就开始填充下一行。但是这种做法是非常危险的，因为额外的元素会影响剩下的初始化式。

### 8.2.2 常量数组

无论一维数组还是多维数组，都可以通过在声明的最开始处加上单词`const`而成为常量。程序不应当对常量数组中的元素进行修改。

`const`类型限定符不仅仅限于数组，后面将看到，它可以和任何变量一起使用。

## 8.3 C99中的变长数组

数组变量的长度这里也可以使用非常量的表达式进行定义。

变长数组的长度是在程序执行时进行计算的，而不是在程序编译的时候。

# 第9章 函数

**<u>函数简单来说就是一连串的语句，这些语句被组合在一起，并被指定了一个名字。</u>**

C语言中，函数不一定要有参数，也不一定要计算数值。

函数是C程序的构件块。每个**函数本质上是一个自带声明和语句的小程序**。可以利用函数把程序划分成小块，这样便于理解、修改和复用程序。

## 9.1 函数的定义和调用

#### 程序：计算平均值

```C
/******************************
 * Caculate the average value *
 ******************************/
double average(double v1, double v2) { return (a + b) / 2; }
```

函数开始处放置的单词`double`表示`average`函数的**返回类型**，也就是每次调用该函数时返回的数据类型。标识符`v1`和标识符`v2`（即函数的**形式参数**）表示在调用`average`函数时需要提供的两个数。每一个形式参数都必须有类型。函数的**形式参数本质上是变量**，其初始值在调用函数的时候才提供。

每个函数都有一个用花括号括起来的执行部分，称为**函数体**。

为了**调用函数**，需要写出函数名以及跟随其后的**实际参数列表**。调用函数就是把实际参数的值**复制**给形式参数，然后执行函数体。

如果函数没有任何返回值，那么就使用`void`指明它的返回值类型，并且省略`return`语句。并且调用没有返回值得函数调用语句必须自成一个语句。

对于一些根本没有形式参数的函数，可以声明为：

```C
void func1();
void func2(void); // 使用void作为形式参数列表占位符
```

两种声明方式都是可以的，其中后者的形参列表中由`void`作为占位符。

### 9.1.1 函数定义

函数定义的一般格式：

```C
返回类型 函数名(形式参数列表)
{
    声明
    语句
}
```

**函数的返回类型**是**函数返回值的类型**。下列规则用来管理返回类型：

* **函数不能返回数组（只能返回指向数组的指针）**！但是关于返回类型没有其他限制。
* 指定返回类型是`void`类型说明函数没有返回值。
* 如果省略返回类型，C89会默认为`int`类型，<u>但是C99中是**非法**的</u>。
* 如果返回类型很冗长，那么把返回类型放在单独的一行是非常有用的。

需要在每个形式参数的前面说明其类型，形式参数之间使用逗号进行分隔。如果函数没有形式参数，**那么最好将形式参数列表写成`void`**。

### 9.1.2 函数调用

函数调用由函数名和跟随其后的实际参数列表组成，其中实际参数列表使用圆括号括起来，圆括号被称为**函数调用运算符**。

注意，**`printf`函数返回显示的字符个数**。

为了清楚的表示函数的返回值是被故意丢掉的，C语言允许在函数调用前加上`(void)`：

```C
(void)printf("Hello World\n"); // 强制转换成void即丢弃返回值
```

#### 程序：判定素数

```C
/***********************************
 * Check whether a number is prime *
 ***********************************/

#include <stdio.h>
#include <stdbool.h>

bool is_prime(int val); /* 函数的前置声明 */

int main(int argc, char const *argv[])
{
    int num;
    printf("Enter a number: ");
    scanf("%d", &num);
    if (is_prime(num)) {
        printf("Is prime.");
    } else {
        printf("Not prime.");
    }
    return 0;
}

bool is_prime(int val)
{
    int half = val / 2;
    for (int i = 2; i <= half; ++i) {
        if (val % 2 == 0) return false;
    }
    return true;
}

// Enter a number: 34
// Not prime.
// Enter a number: 13
// Is prime.
```

在一个函数中可以声明与另一个函数中变量同名的变量，因为这两个变量分属不同的作用域，所以在内存中的地址也不相同。

函数中可以有多条`return`语句。但是在任何一次函数调用中只能执行其中一条`return`语句，这是因为**到达`return`语句之后程序控制器就会返回到函数调用点**。

## 9.2 函数声明

在调用前声明每个函数。**函数声明使得编译器可以先对函数进行概要浏览，而函数的完整定义以后再给出**。

函数声明的格式：`返回类型 函数名(形式参数列表);`

这种函数声明称为**函数原型**。原型为如何调用函数提供了完整的描述：**提供了多少实际参数，这些参数应该是什么类型，以及返回的结果是什么类型**。

C99遵循这样的规则：**在调用一个函数之前，必须先对其进行声明或者定义。调用函数时，如果此前编译器未见到该函数的声明或者定义，就会报错**。

## 9.3 实际参数

* **形式参数**：出现在函数定义中，它们以“假名字”来表示函数调用时需要调用的值。
* **实际参数**：出现在函数调用时，调用运算符中的以逗号运算符分隔的表达式。

C语言中，<u>**实际参数是通过值传递的！是通过值传递的！是通过值传递的！**</u>也就是说，**在调用函数的时候，计算出每个实际参数的值并且把它<u>复制</u>给相应的形式参数。在函数执行的过程中，对形式参数的改变不会影响实际参数的值。**

### 9.3.1 实际参数的转换

C语言允许在实际参数的类型与形式参数的类型不匹配的情况下完成函数的调用。

* 编译器在调用前遇到原型：每个实际参数的值被隐式的转换成相应的形式参数的类型。
* **编译器在调用前没有遇到原型。编译器报错**。

### 9.3.2 数组型实际参数

当形式参数是一维数组时，可以不说明数组的长度：

```C
int func(int arr[]) // 这里不用说明数组的长度
{
    ...
}
```

实际参数可以是元素类型正确的任何一维数组。但是在C语言中，**<u>没有为函数提供任何简便的方法来确定传递给它的数组的长度，如果需要函数知道数组的长度，我们必须要把数组的长度作为额外的参数提供出来</u>**。

虽然可以使用`sizeof`运算符计算出数组变量的长度，但是**无法计算出关于数组形式参数的正确长度**。

把数组名传递给函数时，不要在数组名（实参）的后面放置方括号，直接传入数组的名字就好。

#### 关于数组型实际参数的重要论点

* **函数无法检测传入的数组长度的正确性**。
* **函数可以改变数组型形式参数的元素**，而且改变会在相应的实际参数中体现出来。
* 如果形式参数是多维数组，声明参数时只能省略第一维的长度。

### 9.3.3 变长数组形式参数（C99）

如果使用变长数组形式参数，我们可以明确说明数组`arr`的长度就是`n`：

```C
int sum_array(int n, int arr[n]) { // 这里n的声明必须在数组之前
    ...
}
```

第一个参数`n`的值确定了第二个参数`arr`的长度。注意：这里交换了形式参数的顺序，使用变长数组形式参数时参数的顺序很重要，比方说下面的定义方式就是违法的：

```C
// 非法：n没有声明就被arr使用了：
int sum_array(int arr[n], int n) {
    ...
}
```

### 9.3.4 在数组参数声明中使用static（C99）

C99允许在数组参数声明中使用关键字`static`。

```C
// 将static放在数字3之前表明数组arr的长度至少可以保证是3：
int sum_array(int arr[static 3]) {
    ...
}
```

**如果数组参数是多维的，`static`仅仅可以应用于第一维**。

### 9.3.5 复合字面量（C99）

复合字面量：通过指定其包含的元素而创建的没有名字的数组。

复合字面量的格式：**现在一对圆括号内给定类型名，随后在一对花括号内设定所包括的元素的值**。

## 9.4 return语句

非`void`函数必须使用`return`语句来指定将要返回的值。当然如果没有给出表达式，`return`语句可以出现在返回类型为`void`的函数中。

**程序使用非返回值函数的返回值的行为是未定义的**。

## 9.5 程序终止

正常情况下，`main`函数的返回类型是`int`类型。

**省略函数的返回类型在C99中是非法的，所以禁止这样做**！省略`main`函数的形参列表是合法的，但是从风格上来说最好显式的使用`void`表明一个函数没有参数。

**`main`函数的返回值是状态码**，在某些操作系统中程序终止时可以检测到状态码。

#### exit函数

在`main`函数中执行`return`语句是一种终止程序的办法，另一种办法就是调用`exit`函数，此函数属于`<stdlib.h>`。传递给`exit`函数的实际参数和`main`函数的返回值具有相同的含义：两者都返回程序终止时的状态。

`return`语句和`exit`函数的区别是：<u>**不管哪个函数调用exit函数都会导致程序终止。**</u>

## 9.6 递归

如果函数要调用其自身，那么此函数就是递归的。

使用递归的核心要素在于终止条件，如果没有终止条件会产生无穷递归。

# 第10章 程序结构

## 10.1 局部变量

我们把声明在**函数体内的变量**称为该函数的**局部变量**。

### 局部变量的默认性质

* **自动存储期限**：变量的**自动存储期限**是<u>在变量存储单元存在期内程序执行的部分</u>。局部变量的存储单元是在包含该变量的函数被调用时自动分配的，函数返回时收回分配，所以称这种变量具有**自动的存储期限**。包含局部变量的函数返回时，局部变量的值无法保留。
* **块作用域**：变量的作用域是可以引用该变量的程序文本部分。**局部变量**拥有块作用域：**<u>从变量声明的点开始一直到所在函数体的末尾</u>**。因为局部变量的作用域不能延伸到所在函数之外，所以其他函数可以把同名变量用于别的用途。

C99不要求在函数一开始就进行局部变量声明，所以局部变量的作用域可能非常小。

### 10.1.1 静态局部变量

在局部变量声明中放置单词`static`可以使变量具有**静态存储期限**而不再是**自动存储期限**。因为**具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值**。

静态变量是对其他函数隐藏数据的地方，但是他会为将来同一个函数的再调用保留这些数据。

### 10.1.2 形式参数

形式参数拥有和局部变量一样的性质：**自动存储期限**和**块作用域**。

形式参数和局部变量的唯一真正区别：**在每次函数调用时对形式参数自动进行初始化**。

## 10.2 外部变量

函数还可以通过外部变量进行通信。**外部变量**是声明在任何函数体之外的变量。

外部变量（全局变量）的性质不同于局部变量：

* **静态存储期限**：存储在外部变量中的值将永久的保存下来。
* **文件作用域**：从变量被声明的点开始一直到所在文件的末尾。

### 10.2.1 示例：用外部变量实现栈

C语言中实现栈的一种方法就是把元素存储在数组中。

### 10.2.2 外部变量的利与弊

大多数情况下，对于函数而言，**通过形式参数进行通信**比通过共享变量的方法更好。

## 10.3 程序块

程序块：`{ 多条声明 多条语句 }`

默认情况下，声明在程序块中的变量的存储期限是自动的：**进入程序块时为变量分配存储单元，退出程序块时回收分配的空间**。变量具有块作用域，也就是说，不能在程序块外引用。

函数体就是程序块。C99允许在程序块的任何地方声明变量，就像允许在函数体内的任何地方声明变量一样。

## 10.4 作用域

<u>**当程序块内的声明命名一个标识符时，如果此标识符已经是可见的，新的声明临时隐藏了旧的声明，标识符获得了新的含义。在程序块的末尾，标识符重新获得旧的含义。**</u>

## 10.5 构建C程序

程序可以包含：

* 诸如`#include`和`#define`这样的预处理指令；
* 类型定义；
* 外部变量声明；
* 函数原型；
* 函数定义；

**执行到预处理指令所在的代码行时，预处理指令才会起作用；类型名定义后才可以使用；变量声明后才可以使用；在第一次调用函数前要对每个函数进行定义和声明。**

**为了遵守规则，下面是建议的程序编写顺序**：

* `#include`指令；
* `#define`指令；
* 类型定义；
* 外部变量的声明；
* 除`main`函数之外的函数的原型声明；
* `main`函数的定义；
* 其他函数的定义；

<u>最后建议</u>：在每个函数的定义前放置注释可以给出函数名和函数功能概述等等辅助理解的文本。

# 第11章 指针

指针是C语言最重要也是最常被误解的特性之一，本章是三章中的基础章。

## 11.1 指针变量

大多数现代计算机都将内存分割为**字节**（byte），每个字节可以存储8**位**（bit）的信息。

每个字节都有唯一的**地址**（address），用来和内存中的其他字节相区别。如果内存中有`n`个字节，那么可以把地址看作`0 ~ n-1`的数字。

程序中的每个变量占有一个或者多个字节的内存，**把占有的第一个字节的地址称为变量的地址**。

C语言中不使用普通的整形变量存储地址，这里使用特殊的指针变量存储地址。**在用指针变量`p`存储变量`i`时，我们描述为`p`指向`i`**。换句话说，**<u>指针就是地址，而指针变量就是存储地址的变量</u>**。

#### 指针变量的声明

对指针变量的声明与对普通变量的声明基本一样，唯一的不同就是必须在指针变量名字前放置星号，也就是构成**复合类型**。

```C
int* pointer;
```

**<u>C语言要求每个指针变量只能指向一种特定类型的变量</u>**。

## 11.2 取地址运算符和间接寻址运算符

为了获得变量的地址，可以使用`&`（**取址**）运算符。如果`x`是变量，那么`&x`就是变量`x`在内存中的地址。为了访问指针中所存储的地址上的内容，可以使用`*`（**间接寻址**）运算符。

### 11.2.1 取地址运算符

声明指针变量是为指针留出空间，但是并没有把它指向对象。在使用前初始化指针变量是非常重要的：

```C
int i = 10;
int* ip = &i; // 初始化一个指针
```

### 11.2.2 间接寻址运算符

一旦变量指向了对象，就可以使用`*`（**间接寻址**）运算符访问指针存储的地址上的内容。

```C
int i = 1024;
int* ip = &i;
printf("%d\n", *ip); // 1024
```

只要`ip`指向了`i`，`*ip`就是`i`的别名。它们不仅拥有相同的值，而且对前者的操作也会影响到后者。

**严禁把间接寻址运算符用于未初始化的指针变量**！如果指针变量没有被初始化，那么试图使用指针变量的值会导致未定义的行为。

## 11.3 指针赋值

## 11.4 指针作为参数

因为C语言使用值进行参数传递，所以在函数调用中作实际参数的变量无法改变。

指针提供了此问题的解决方法：不再传递变量本身作为函数得实际参数，而是传递变量的地址。传递流程变成了**<u>实参指针将自己存储的地址复制给形参指针，如果想要修改地址上的内容，形参指针只需要间接寻址复制得到的地址就可以了</u>**。

`scanf`函数的调用就必须传递指针，因为只有指针会告诉`scanf`函数应当把读取的数值存放在内存的什么地方。

#### 使用const保护参数

如果变量需要大量的存储空间，那么值传递的方式将会消耗大量的时间和空间。

可以使用`const`来表明函数不会修改指针存储的地址上的内容。这里应当使用底层`const`：

```C
// 底层const，即不可改变指针指向的内容，而非指针本身：
void func(const int* p) {
    ...
}
```

## 11.5 指针作为返回值

下列函数返回指向两个整数中较大数的指针：

```C
int* get_max(const int* ap, const int* bp) { return *ap > *bp ? ap : bp; }
```

<u>**永远禁止返回指向自动局部变量的指针！**</u>

指针可以指向数组元素，而不仅仅是普通的变量。

# 第12章 指针和数组

当指针指向数组元素时，C语言允许对指针进行算术运算（加法和减法），通过这种运算我们可以**用指针代替数组下标对数组进行处理**。

## 12.1 指针的算术运算

```C
int arr[10]; // 声明一个长度为10的数组arr
int* arrp = &arr[0]; // 指向数组arr的第一个元素

// 可以通过arrp访问arr[0]，比方说把5存入arr[0]：
*arrp = 5; // 等价于arr[0] = 5
```

通过在`arrp`上执行指针算术运算（或者地址算术运算符）可以访问数组`arr`的其他所有元素。C语言支持且仅支持三种格式的指针算术运算：

* 指针加上一个整数；
* 指针减去一个整数；
* 两个指针相减；

### 12.1.1 指针加上整数

指针`arrp`加上整数`j`产生指向特定元素的指针，这个特定的元素是`arrp`原本指向的元素后`j`个位置。确切的说：**如果`arrp`指向元素`arr[i]`，那么`arrp + j`指向`arr[i + j]`**。

### 12.1.2 指针减去整数

如果`arrp`指向元素`arr[i]`，那么`arrp - j`指向`arr[i - j]`。

### 12.1.3 两个指针相减

当两个指针相减时，结果为指针之间的距离（用数组元素的个数来度量）。

```C
int* p1 = &arr[5];
int* p2 = &arr[1];
int i = p1 - p2; // i is 5 - 1 == 4
int j = p2 - p1; // j is 1 - 5 == -4
```

**在不指向任何数组元素的指针上执行算术运算会导致未定义的行为**。并且只有两个指向同一数组的指针相减才有意义。

### 12.1.4 指针比较

**只有在两个指针指向同一数组时，用关系运算符进行的指针比较才有意义**。比较的结果依赖于数组中两个元素的相对位置。

### 12.1.5 指向复合常量的指针（C99）

## 12.2 指针用于数组处理

指针的算术运算允许通过对指针变量进行**重复自增**来访问数组的元素：

```C
int arr[5] = {0}; // 0, 0, 0, 0, 0
for (int i = 1, *p = &arr[0]; i <= 5; ++i, ++p) { *p = i; }
// Now the arr is: 1, 2, 3, 4, 5
```

#### 间接寻址运算符和自增运算符的组合

```C
arr[i++] = j; // 先把j赋值给arr[i]，然后i自增1
*arrp++ = j; // 因为后缀++的优先级高于间接寻址运算符，所以等价于：
*(arrp++) = j; // arrp++的值是arrp，所以这三条语句等价
```

## 12.3 用数组名作为指针使用

可以使用数组的名字作为指向数组第一个元素的指针。

虽然可以把数组名作为指针，但是不能给数组名赋新的值。试图使数组名指向其他地方是错误的。

当使用数组名作为指针的时候，“数组名指针”相当于一个顶层`const`指针。

### 12.3.1 数组型实际参数

**数组名在传递给函数时，总是被视为指针。**把数组形式参数看作是指针会产生很多重要的结果：

* **在给函数传递普通变量时，变量值会被复制**；任何相对应的形式参数的改变都不会影响到变量。反之，因为没有对数组本身进行复制，所以作为实际参数的数组是**可能**被改变的。

  为了指明数组形参（也就是实参）不会被改变，可以在声明中加入`const`：

  ```C
  int find_largest(const int arr[], int n) {
      ...
  }
  ```

* 给函数传递数组所需的时间与数组大小无关。

* 可以把数组形参声明为指针，编译器把这两类声明看作是完全一样的。**对于数组形参而言，声明为数组和声明为指针是完全一样的**。

* 可以给形式参数为数组的函数传递数组的片段。

### 12.3.2 用指针作为数组名

## 12.4 指针和多维数组

## 12.5 C99中的指针和变长数组

# 第13章 字符串

## 13.1 字符串字面量

**字符串字面量**是用一对双引号括起来的字符序列：`"Hello World"`

### 13.1.1 字符串字面量中的转义序列

**字符串字面量**可以像字符常量一样包含转义序列。

### 13.1.2 延续字符串字面量

如果字符串字面量太长而无法放置在单独一行内，只要把第一行用`\`字符结尾，那么C语言就允许在下一行延续字符串字面量。

使用`\`有个问题：**字符串字面量必须从下一行的起始位置继续，这就破坏了缩进结构**。这就需要一种更好的方法：**当两条或者更多条字符串字面量相邻时（仅用空白字符分割），编译器会自动把它们合成一条字符串**。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    printf("hello, " "world");
    return 0;
}

// output:
// hello, world
```

### 13.1.3 如何存储字符串字面量

本质上，**<u>C语言把字符串字面量作为字符数组来处理</u>**。当C语言编译器在程序中遇到长度为`n`的字符串字面量时，它会为字符串字面量分配长度为`n + 1`的内存空间。这块内存空间将用来存储字符串字面量中的字符，**以及一个用来标志字符串末尾的格外字符（空字符）**。**空字符是一个所有位都为`0`的字节**，因此用转义序列`\0`来表示。空字符的ASCII编码值为`0`。

字符串字面量可以为空。字符串`""`作为单独一个空字符来存储，即看起来空的字符串中实际上有一个空字符`'\0'`。

既然字符串字面量是作为数组来存储的，那么编译器会把它看作是`char*`类型的变量。

### 13.1.4 字符串字面量的操作

通常情况下可以在任何C语言中允许使用`char*`类型变量的地方使用字符串字面量。

把字符串字面量赋给字符指针变量不是复制其中的字符，而是使字符指针指向字符串的第一个字符。

C语言允许对指针取下标，因此可以对字符串字面量取下标。

**试图改变字符串字面量会导致未定义的行为，改变字符串字面量可能会导致程序崩溃或者运行不稳定。**

### 13.1.5 字符串字面量与字符常量

只包含一个字符的字符串字面量不同于字符常量：**字符串字面量`"a"`是用指针来表示的，这个指针指向存放字符串`"a"`（后面紧跟空字符）的内存单元。字符常量`'a'`是用整数（字符集的数值码）来表示的**。

`printf`函数期望指针作为它的第一个参数。

## 13.2 字符串变量

**只要保证字符串是以空字符结尾的，任何一维的字符数组都可以用来存储字符串。**

千万要注意正确的处理空字符。而且，**要确定字符串长度没有比线性搜索空字符更快的方法了**。

当声明用于存放字符串的字符数组时，要始终保证**数组的长度比字符串的长度多一个字符。这是因为C语言规定每个字符串都要以空字符结尾。如果没有给空字符预留位置，可能会导致未定义的结果，因为C函数库中的函数都市默认字符串是以空字符结束的。**

**字符串的长度取决于空字符的位置，而不是却决于用于存放字符串的字符数组的长度**：

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char s[20] = "Hello World"; /* 初始化字符串变量 */
    for (int i = 0; i < 20; ++i) {
        if (s[i] == '\0') {
            putchar('\n');
            printf("Here is the end of the string!\n");
            printf("The index right now is: %d.\n", i);
            return 0;
        } else {
            putchar(s[i]);
        }
    }
    return 0;
}

// output:
// Hello World
// Here is the end of the string!
// The index right now is: 11.
```

### 13.2.1 初始化字符串变量

当我们时用字符串字面量初始化字符数组时，C编译器会把字符串字面量看成是数组初始化的缩写形式：

```C
char[20] s1 = "Hello World";
// 本质上等价于：
char[20] s1 = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
```

**<u>如果初始化式太短导致不能填满字符数组，编译器会把剩下的空间全部塞满空字符</u>**：

```C
char[15] s1 = {'H','e','l','l','o',' ','W','o','r','l','d','\0'};
// 等价于：
char[15] s1 = {'H','e','l','l','o',' ','W','o','r','l','d','\0','\0','\0','\0'};
```

比方说：

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char s[15] = "Hello World";
    for (int i = 0; i < 15; ++i) {
        if (s[i] == '\0') {
            printf("\\0");
        } else {
            putchar(s[i]);
        }
    }
    putchar('\n');
    return 0;
}

// output:
// Hello World\0\0\0\0
```

**字符串字面量比字符数组长是非法的，<u>严禁字符串字面量的长度超过字符数组的长度</u>。**

如果字符串字面量和字符数组等长，编译器不会报错，但是编译器会在赋值的时候忽略空字符，这样就使得这样的字符数组无法作为字符串使用。

### 13.2.2 字符数组与字符指针

```C
char date[] = "June 14";
char* date = "June 14";
```

前者声明的是一个数组，后者声明的是一个指针。上面两种都可以作为字符串的声明。任何期望传递字符数组或者字符串指针的函数都能接受这两种声明的`date`作为参数。

然而需要注意的是：**<u>不能错误的认为上面这两种`date`声明方式可以互换</u>**，两者存在很大的差异：

* **在声明为数组时，就像任意数组元素一样，可以修改存储在`date`中的字符。在声明为指针时，`date`指向的是一个字符串字面量，而字符串字面量是不可修改的。**
* **在声明为数组时，`date`是数组名。在声明为指针时，`date`是变量，这个变量可以在程序执行期间指向其他字符串。**

**如果希望可以修改字符串，那么就要建立字符数组来存储字符串**，声明指针变量就不行。

## 13.3 字符串的读写

### 13.3.1 用printf函数和puts函数写字符串

说明转换符`%s`允许`printf`函数写字符串：

```C
char str[] = "Hello World";
printf("%s\n", str);
```

`printf`函数会逐个写字符串中的字符，直到遇到空字符才停止。如果空字符丢失，`printf`函数会越过字符串的末尾继续写，直到在内存中碰到一个空字符才会停止。

如果只想显示字符串的一部分，可以使用转换说明`%.ps`，`p`是要显示的字符数量。

**`puts`函数只有一个参数，即需要显示的字符串。在写完字符串之后，`puts`函数总会<u>添加一个额外的换行符</u>，从而前进到下一个输出行的开始处。**

### 13.3.2 用scanf函数和gets函数读入字符串

调用`scanf`函数的时候，字符串参数之前不要添加取地址符，因为字符数组的名字或者字符指针本身就会被视为指针变量。调用时，**`scanf`函数会跳过空白字符，然后在遇到空白字符之前把遇到的字符读入传入的字符串容器中**。`scanf`函数始终会在字符串末尾添上一个空字符。

**<u>使用`scanf`函数读入的字符串永远不会包含空白字符。</u>**换行符、空格符和制表符都会使`scanf`函数停止读入。

为了一次读入一整行输入，需要使用`gets`函数。类似于`scanf`函数，**`gets`函数把读入的字符放到字符数组中，然后在末尾加上一个空字符**。然而在其他方面`gets`函数有些不同于`scanf`函数：

* `gets`函数**不会在开始读入字符串之前跳过空白字符**。
* `gets`函数会持续读入直到找到换行符才停止。`gets`函数会**忽略掉换行符**，不会把它存储在数组中。

```C
#include <stdio.h>

int main(int argc, char const *argv[])
{
    char s1[50];
    char s2[50];
    printf("Enter a sentence: ");
    scanf("%s", s1);
    gets(s2);
    printf("What scanf got: %s\n", s1);
    printf("What gets got: %s\n", s2);
    return 0;
}

// Enter a sentence: To be or not to be, it is a question.
// What scanf got: To
// What gets got:  be or not to be, it is a question.
```

**把字符读入数组时，`scanf`函数和`gets`函数都无法检测数组何时被填满**。因此，它们存储字符时可能越过数组的边界，这会导致**未定义**的行为。

### 13.3.3 逐个字符读取字符串

## 13.4 访问字符串中的字符

字符串是以数组的方式存储的，因此可以使用下标来访问字符串中的字符。

## 13.5 使用C语言的字符串库

在C语言中把字符串当作数组来处理，因此对字符串的限制方式和对数组一样，特别是，它们都不能用C语言的运算符进行复制和比较操作。**直接复制或者比较字符串都会失败**。

声明中的赋值运算符解释为初始化运算符，数组不可以被赋值但是可以被初始化。

C语言的字符串函数库位于`<string.h>`中。包含的函数每个至少需要一个字符串作为实际参数。字符串形式参数声明为`char*`类型。

### 13.5.1 strcpy函数

负责把s2复制给s1的的函数，原型如下：`char* strcpy(char* s1, const char* s2);`

```C
char* strcpy(char* s1, const char* s2)
{
    char* s1_temp = s1;
    char* s2_temp = s2;
    while (*s2_temp != '\0') {
        *s1_temp = *s2_temp;
        s1_temp += 1;
        s2_temp += 1;
    }
    s1_temp += 1;
    *s1_temp = '\0'; // 添加上空字符用来结尾
    return s1;
}
```

在`strcpy`函数的调用过程中，`strcpy`函数无法检查`s2`指向的字符串大小是否真的适合`s1`指向的数组。**如果`s2`长于`s1`的数组长度，那么结果是未定义的**（因为`strcpy`函数会一直复制到第一个空字符为止，所以它会越过`s1`的边界继续复制）。

### 13.5.2 strlen函数

字符串长度函数的圆形如下：`size_t strlen(const char* s);`

```C
size_t strlen(const char* s)
{
    size_t len = 0;
    for (; *s != '\0'; ++len, ++s);
    return len;
}
```

### 13.5.3 strcat函数

字符串拼接函数的原型如下：`char* strcat(char* s1, const char* s2);`

```C
char* strcat(char* s1, const char* s2)
{
    char* curr_pos = s1;
    while (*curr_pos != '\0') ++curr_pos;
    while (*s2 != '\0') {
        *curr_pos = *s2;
        ++curr_pos;
        ++s2;
    }
    ++curr_pos;
    *curr_pos = '\0'; // 添加上空字符用来结尾
    return s1;
}
```

**如果`s1`指向的数组不足以容纳拼接后的字符串，那么结果是不可预测的。**

### 13.5.4 strcmp函数

`strcmp`函数比较字符串`s1`和`s2`，然后根据`s1`是小于、等于或者大于`s2`，返回一个小于，等于或者大于`0`的值。

## 13.6 字符串惯用法

## 13.7 字符串数组

C语言允许省略字符串二维数组在初始化的时候省略行数，但是要求必须指明列数。

如果有更加节省空间的存储字符串数组的方式，就是将字符串数组声明为字符指针的数组：`char* sarr[10];`。这个声明了一个存储有10个字符指针的数组，每个字符指针就可以指向一个字符串字面量或者字符数组。

# 第16章 结构、联合和枚举

* 结构可能是具有不同类型的值（成员）的集合。
* 联合和结构类似，但是**联合的成员共享同一个存储空间**。
* **枚举是一种整数类型**，其值由程序员命名。

## 16.1 结构变量

数组的两个重要特性：

* 数组的元素具有相同的类型；
* 为了选择数组元素需要指明元素的位置（循秩访问）；

结构的元素（成员）可能具有不同的类型。而且每个结构成员都有名字，所以为了选择特定的结构成员需要指明其对应的名字，而不是它的位置。

### 16.1.1 结构变量的声明

如果设计一个存储零件信息的结构：

```C
struct {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
} part1, part2;
```

每个结构变量都有三个成员：`number`，`name`和`on_hand`。`struct {...}`指明了类型，**而`part1`和`part2`则是具有上述类型的变量**。

结构的成员在内存中是按照**声明的顺序**存储的。

每个结构代表一种新的作用域。任何在结构内部声明的名字都不会和程序中的其他名字冲突。

### 16.1.2 结构变量的初始化

和数组一样，结构变量也可以在声明的同时进行初始化：

```C
struct {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
} part1 = { 528, "Disk", 10 },
  part2 = { 914, "Cable", 5 };
```

结构初始化式遵循的原则类似于数组初始化的原则。用于结构初始化式的表达式必须是常量。

### 16.1.3 指定初始化（C99）

初始化可以被指定：

```C
struct {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
} part1 = { .number = 528, .name = "Disk", .on_hand = 10 };
```

点运算符和成员名称的组合称为**指示符**。

指定初始化的优势：

* 易读且容易进行验证。
* 初始化式中的值得顺序**不需要**与结构中成员的顺序一致。

**警告：<u>无指示符和有指示符的形式不能混用</u>。**

### 16.1.4 对结构的操作

结构成员是通过名字而不是位置进行访问的。我们需要使用**点运算符**（`.`）来访问结构的成员。点运算符的优先级几乎高于所有其他运算符。

**<u>结构可以进行赋值</u>**：`part2 = part1;`

对结构进行复制时，嵌在其中的数组成员也可以得到复制，一些程序员利用这个性质来产生空的结构，以封装稍后将进行复制的数组。

**除了赋值运算，C语言没有提供其他用于整个结构的操作**。特别是<u>**不能使用相等或者不等运算符来判断两个结构的关系**</u>。

## 16.2 结构类型

C语言允许定义结构类型的名字。C语言提供了两种命名结构的方法：

* 声明“结构标记”；
* 也可以使用`typedef`来定义类型名；

### 16.2.1 结构标记的声明

**结构标记**是用于标识某种特定结构的名字：

```C
// 注意这样声明的结构不能当作类型来使用：
struct Part {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
};

// 声明形式为：struct Part p1;
```

其中`Part`就是这个结构的**标记**，右花括号的分号是必不可少的，它表示声明结束。**<u>注意结构标记不等于结构类型</u>**。

一旦标记了某种结构，就可以用结构的标记来声明变量了：

```C
struct Part {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
};

void func() {
    struct Part p1; // 不能通过漏掉单词struct来缩写这个声明
    // Part p1; 这样的声明在C语言中是错误的！必须加上struct关键字
    // ...
}
```

### 16.2.2 结构类型的定义

除了声明结构标记，还可以使用`typedef`来定义真实的类型名：

```C
typedef struct {
    int number;
    char name[20];
    int on_hand;
} Part;
```

注意：**<u>类型Part的名字必须出现在定义的末尾，而不是在`struct`的后面</u>**。

**<u>使用这种方式声明的`Part`就是个彻底的类型，所以在声明变量的时候可以直接当作类型来使用，而不用加上`struct`关键字。</u>**

### 16.2.3 结构作为参数和返回值

函数可以有结构类型的实际参数和返回值：

```C
#include <stdio.h>
#include <string.h>

struct Part { // 这样的声明方式Part仅仅是个结构标记，不是结构类型
    int number;
    char name[20];
    int on_hand;
};

void print_part(struct Part p)
{
    printf("Part number: %d\n", p.number);
    printf("Part name: %s\n", p.name);
    printf("Quantity on hand: %d\n", p.on_hand);
}

struct Part build_part(int number, const char* name, int on_hand)
{ // 这种其实就是构造函数的最初形态
    struct Part p;
    p.number = number;
    strcpy(p.name, name);
    p.on_hand = on_hand;
    return p;
}
```

**传递指向结构的指针来代替传递结构本身是非常明智的做法**。相同的，也可以使用返回传入的指针来减少开销。当然还有一种情况就是对象本身不允许进行复制。

### 16.2.4 复合字面量（C99）

复合字面量可以用于“实时”创建一个结构，而不需要将其存储在变量中。

## 16.3 嵌套的数组和结构

新的可能性：成员是结构的结构，元素是结构的数组。

### 16.3.1 嵌套的结构

### 16.3.2 结构数组

数组和结构最常见的组合之一就是**其元素为结构的数组**。这类数组可以用作简单的线性或者树形数据库。

### 16.3.3 结构数组的初始化

## 16.4 联合（TODO）

联合也是由一个或者多个成员构成的，而且这些成员可能具有不同的类型。但是，编译器只为联合中最大的成员分配足够的内存空间。联合的成员在这个空间内彼此覆盖。这样的一个结果是，给一个成员赋予新值也会改变其他成员的值。

### 16.4.1 用联合来节省空间

### 16.4.2 用联合来构造混合的数据结构

### 16.4.3 为联合添加“标记字段”

## 16.5 枚举（TODO）

有时我们需要变量只具有少量意义的值，比方说布尔量应该只有真和假，扑克的花色只有梅花，方片，红桃和黑桃。枚举就是这样的一种数据类型，枚举类型是一种值由程序员列出的类型，而且程序员必须为每个值命名。

### 16.5.1 枚举标记和类型名

# 第17章 指针的高级应用

本章讲解动态存储分配和指向函数的指针。

## 17.1 动态存储分配

C语言的数据结构通常是固定大小的，也就是说，在不修改程序并且再次编译程序的情况下无法改变数据结构的大小。

C语言支持动态存储分配，即在程序执行期间分配内存单元的能力。利用动态存储分配，可以设计出能根据需要改变容量的数据结构。

### 17.1.1 内存分配函数

涉及动态内存分配的函数都声明在`<stdlib.h>`头文件中：

* **`malloc`函数：分配内存块，但是不对内存块进行初始化。**
* `calloc`函数：分配内存块，并且对内存块进行清零。
* `realloc`函数：调整先前分配的内存块大小。

这三种函数中，`malloc`函数是最常用的一种。因为`malloc`函数不需要对分配的内存块进行清零，所以更高效。

当申请内存块而调用内存分配函数时，由于函数无法知道计划存储在内存块中的数据是什么类型的，所以分配函数无法返回`int`类型，`char`类型等普通类型的指针。取而代之的，函数会返回`void*`类型的值。`void*`类型的值是“通用指针”，**本质上它只是内存地址**。

### 17.1.2 空指针

当分配函数找不到满足我们需要的足够大的内存块时，函数会返回空指针。空指针是“不指向任何地方的指针”，这是一个却别于所有有效指针的特殊值。

程序员的责任是测试任意内存分配函数返回的指针，并且在返回空指针时采取适当的动作。

**空指针使用名为`NULL`的宏来表示。**

## 17.2 动态分配字符串

可以通过动态分配，来将一些容器的大小推迟到程序运行时才作决定。

### 17.2.1 使用malloc函数为字符串分配内存

`malloc`函数的原型：`void* malloc(size_t size);`

**`malloc`函数分配`size`个字节的内存块，并且返回指向该内存块的指针**。除非正在分配一个非常巨大的内存块，否则将`size`考虑成普通整数。

```C
char* p1 = (char*)malloc(n + 1); // 将void*类型强行转换成为char*类型
char* p2 = malloc(n + 1); // 这样也可以，通用指针会自动转换成为char*类型
```

### 17.2.2 在字符串函数中使用动态存储分配

自行编写的函数将测量用来连接的两个字符串的长度，然后调用`malloc`函数为结果分配合理的内存大小空间。

```C
char* concat(const char* s1, const char* s2)
{
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    char* new_s = (char*)malloc(sizeof(char) * (len1 + len2 + 1));
    if (new_s == NULL) { // 这里需要加一个内存分配的检查
        printf("Error: malloc failed in concat\n");
        return NULL;
    }
    strcpy(new_s, s1);
    strcat(new_s, s2);
    return new_s;
}
```

当调用含有动态分配存储空间的函数必须小心，当不再需要`concat`函数返回的字符串时，需要使用`free`函数进行释放空间。如果不这样做，程序最终会用光内存。

### 17.2.3 动态分配字符串的数组

## 17.3 动态分配数组

虽然`malloc`函数可以为数组分配内存空间，但有时会用`calloc`函数代替`malloc`，因为`calloc`函数会对分配的内存进行初始化。`realloc`函数会根据需要对数组进行扩展和缩减。

### 17.3.1 使用malloc函数为数组分配存储空间

我们需要使用`sizeof`运算符来计算出每个元素所需要的空间数量。

假设我们需要程序生成`n`个整数构成的数组，这里的`n`可以在程序执行期间计算出来：

```C
int* arr; // 首先声明指针变量
// ...
// 一旦计算出数组的长度，就让程序调用malloc函数为数组分配存储空间：
arr = (int*)malloc(sizeof(int) * n);
```

**计算数组所需要的空间数量时始终要使用`sizeof`运算符。如果不能分配足够的内存空间，会产生严重的后果。**

一旦指针指向了动态分配的内存块，指针就可以用作数组名了。

### 17.3.2 calloc函数

`calloc`函数在`<stdlib.h>`中具有的原型：`void* calloc(size_t nmemb, size_t size);`

解释为：**`通用指针 calloc(size_t 数组长度, size_t 数组元素大小);`**

`calloc`函数为`nmemb`个元素的数组分配内存空间，其中每个元素的长度都是`size`个字节。如果要求的空间无效，那么此函数返回空指针。

在成功分配内存之后，`calloc`函数会把内存上的所有位重置为`0`的方式对数组进行初始化。比方说：

```C
int* arr = (int*)calloc(10, sizeof(int));
// 得到一个长度为10的int类型数组，并且每个元素的值都为0
```

通过调用以`1`作为第一个实际参数的`calloc`函数，可以为任何类型的数据项分配空间：

```C
char* chp = (char*)calloc(1, sizeof(char)); // 一个指向字符的指针
```

### 17.3.3 realloc函数

一旦为数组分配完内存，稍后可能会发现数组过大或者过小。`realloc`函数可以调整数组的大小使它更适合需要。

`realloc`函数原型：`void* realloc(void* ptr, size_t size);`

当调用`realloc`函数时，需要指明需要重新分配大小的对象和重新分配的具体内存数量。这里要确定传递给`realloc`函数的指针来自于先前`malloc`、`calloc`或者`realloc`的调用，否则可能引发严重问题。

#### C语言标准列出的几条关于realloc函数的规则

* 当扩展内存块时，`realloc`函数不会对新添加进内存块的字节进行初始化。（**不会初始化内存块**）
* **如果`realloc`函数不能按要求扩大内存块，那么返回空指针，并且维持原有内存块数据不变。**
* **如果`realloc`函数被调用时以空指针作为实际参数，那么就会退化为`malloc`函数。**
* **如果`realloc`函数被调用时以`0`作为第二个实际参数，那么它会释放掉内存块。**

```C
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
    int* arr = (int*)calloc(5, sizeof(int)); // 分配一个数组长度为5的int类型数组
    for (int i = 0; i < 5; ++i) printf("%d ", arr[i]); // 输出
    printf("\n");
    realloc(arr, 0); // 调用realloc函数，利用特性释放内存
    return 0;
}
```

一旦`realloc`函数成功返回，一定要对所有指向之前内存块的指针进行更新，因为`realloc`函数可能会将原来的内存块整体搬迁。

## 17.4 释放存储空间

三个内存分配函数所能分配的空间其实都来自一个称为**堆**的内存池。过于频繁的调用动态分配内存函数可能会耗尽堆内存。导致函数返回空指针。

更普遍的情况是程序分配了内存块，但是后续又失去了对这些块的控制。这就让很多内存块成为了无主之地，无法被释放，从而占用了很多空间。

对于程序而言，**失去控制权的内存块**被称为**垃圾**。**留有垃圾的程序**就被称为有**内存泄漏**现象。一些语言提供**垃圾回收**用于**释放不受控制的内存块**，但是C语言不提供。C语言的垃圾回收需要程序员自己调用`free`函数。

### 17.4.1 free函数

`free`函数的原型也在`<stdlib.h>`中：`void free(void* ptr);`

使用`free`函数也很简单，只需要简单的把不再需要的内存块的指针传递给`free`函数就可以了：

```C
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{
    int* arr = (int*)calloc(5, sizeof(int));
    for (int i = 0; i < 5; ++i) { printf("%d ", arr[i]); }
    printf("\n");
    free(arr); // 释放内存
    arr = NULL; // 解决悬空指针的问题
    return 0;
}
```

调用`free`函数会释放指针所指向的内存块。然后此内存块可以被后续的动态内存分配函数重新使用。

**`free`函数的实参必须也是动态内存的指针，如果指针指向其他对象，会导致未定义的行为。**

### 17.4.2 “悬空指针”的问题

虽然`free`函数回收了内存块，但是指针变量本身还是不会变的，这样就造成了**指针正在指向一块被清理掉可能随时被其他程序占用的内存**。这种现象就叫**悬空指针**。**试图访问或者修改悬空指针中地址会导致严重的未定义行为**。

悬空指针是很难发现的，因为在大型程序中很难确定当前一块内存上有多少指针正在指向它。

## 17.5 链表

```C
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef struct {
    ListNode* next;
    int val;
} ListNode;

typedef struct {
    ListNode* head;
    ListNode* tail;
    int length;
} LinkedList;

// 创建新的链表结点
ListNode* makeListNode(int val)
{
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        return NULL;
    } else {
        newNode->val = val;
        newNode->next = NULL;
        return newNode;
    }
}

// 向链表中添加新的结点
bool push_back(LinkedList lis, int val)
{
    ListNode* newNode = makeListNode(val);
    if (newNode == NULL) {
        return false;
    } else {
        (lis.tail)->next = newNode;
        lis.length += 1;
        return true;
    }
}
```

### 17.5.1 声明节点类型

```C
typedef struct {
    ListNode* next;
    int val;
} ListNode;

ListNode* makeListNode(int val)
{
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        return NULL;
    } else {
        newNode->val = val;
        newNode->next = NULL;
        return newNode;
    }
}
```

### 17.5.2 创建结点

创建结点的三个步骤：

* 为结点分配内存单元；
* 把数据存储到节点中；
* 把结点插入到链表中；

### 17.5.3 箭头运算符

## 17.6 指向指针的指针

## 17.7 指向函数的指针

C语言的指针不仅能指向数据，还允许指针指向函数。**每个函数都有地址**，就像每个变量都有地址一样。

### 17.7.1 函数指针作为参数

```C
double (*func)(double) = NULL;
```

`func`是一个函数指针，该函数指向一个返回类型是`double`且具有`double`类型形参的函数。

# 第22章 输入输出

本章一章都是要讨论`<stdio.h>`这个头文件，输入输出函数的最主要函数库。

## 22.1 流

**流**（stream）表示任意输入的源或任意输出的目的地。许多小型程序都是通过一个流（通常是键盘或者网络）获得全部的输入，并且通过另一个流（通常是屏幕）写出全部的输出。

请记住一点：`<stdio.h>`中的许多函数可以处理各种形式的流，而不仅仅可以处理表示文件的流。

### 22.1.1 文件指针

C程序中对流的访问是通过文件指针实现的。此指针的类型为`FILE*`。用文件指针表示的特定流具有标准的名字。如果需要，还可以声明另外一些文件指针。

### 22.1.2 标准流和重定向

`<stdio.h>`提供了3个**标准流对象**。这3个标准流可以直接使用——不需要声明，打开或者关闭它们：

* `stdin`（标准输入）：键盘；
* `stdout`（标准输出）：屏幕；
* `stderr`（标准错误）：屏幕；

前面章节使用的比如`printf`函数都是通过`stdin`获得输入，并且使用`stdout`进行输出。默认情况下，`stdin`表示键盘，而`stdout`和`stderr`表示屏幕。许多操作系统允许通过**重定向**来改变这些默认设定。

通常我们**可以强制程序从文件而不是从键盘获得输入**，方法是**在命令行中放上文件的名字，并在前面加上`<`字符**：

```powershell
./demo < in.dat
```

这种方法称为**输入重定向**，它本质上是使`stdin`流表示文件而非键盘。重定向的一个特性是：**demo程序不会意识到正在从文件`in.dat`读取数据，他会认为从`stdin`获得的任何数据都是从键盘录入的。**

输出重定向也是类似的。对stdout流的重定向通常是通过在命令行中放置文件名，并在前面加上字符`>`实现的：

```powershell
./demo > out.dat
```

现在将所有写入stdout的数据都将进入out.dat文件中了，而不是出现在屏幕上。我们还可以把输出重定向和输入重定向结合使用：

```powershell
./demo < in.dat > out.dat
```

### 22.1.3 文本文件与二进制文件

`<stdio.h>`支持两种类型的文件：文本文件和二进制文件。

* 在**文本文件**（text file）中，字节表示字符，这使人们可以检查或者编辑文件（txt文件就是文本文件）。
* 在**二进制文件**（binary file）中，字节不一定表示字符（exe文件就是二进制文件）。

文本文件具有两种二进制文件没有的特性：

* **文本文件分为若干行**：文本文件的每一行通常以一两个特殊字符结尾，特殊字符的选择和操作系统有关。
* **文本文件可以包含一个特殊的“文件末尾”标记**。

编写用来读写文件的程序时，需要考虑文件是文本文件还是二进制文件。

## 22.2 文件操作

简单性是输入输出重定向的魅力之一，不需要打开文件、关闭文件或者执行其他操作。但是限制较多。

### 22.2.1 打开文件

```C
FILE* fopen(const char* restrict filename, const char* restrict mode);
```

如果要把文件用作流，打开时需要调用`fopen`函数。`fopen`函数的第一个参数是**含有要打开文件名的字符串**，这里的文件名要包含文件的位置信息。第二个参数是“**模式字符串**”，它用来指定打算对文件执行的操作。

`restrict`关键字隶属于C99，表明`filename`和`mode`所指向的字符串的内存单元不共享。

`fopen`函数返回一个文件指针，类型是`FILE*`。程序可以把该指针存储在一个变量中，稍后在需要对文件进行操作时使用：

```C
FILE* fp = fopen("in.dat", "r"); // 打开文件
fclose(fp); // 关闭文件
```

**当文件无法被打开时，`fopen`函数返回空指针。**所以不要假设文件可以打开，每次都要测试`fopen`函数的返回值以确保不是空指针。

### 22.2.2 模式

给`fopen`函数传递那种模式字符串不仅依赖于将要采取的操作，还取决于文件的数据形式。

### 22.2.3 关闭文件

```C
int fclose(FILE* filestream);
```

`fclose`函数允许程序关闭不再使用的文件。`fclose`函数的参数必须是文件指针。**如果成功关闭了文件，函数返回`0`；否则将会返回错误代码`EOF`，这个代码定义在`<stdio.h>`中，性质为宏。**

## 22.3 格式化的输入输出

### 22.3.1 ...printf函数

```C
int fprintf(FILE* fileptr, const char* format, ...);
int printf(const char* format, ...);
```

两个函数的返回值就是写入的字符数，若出错则返回一个负值。

`fprintf`函数和`printf`函数唯一的不同就是`printf`函数始终向`stdout`写入内容，而`fprintf`函数则向它自己的第一个实际参数指定的文件中写入内容：

```C
printf("Total: %d\n", total); // writes to stdout
fprintf(fileptr, "Total: %d", total); // writes to fileptr's file
```

### 22.3.5 ...scanf函数

```C
int fscanf(FILE* fileptr, const char* format, ...);
int scanf(const char* format, ...);
```

`fscanf`函数和`scanf`函数从输入流中读取数据，并且使用格式串来指明输入的格式。格式串的后边可以跟有任意数量的指针作为额外的实际参数。

`scanf`函数始终从输入流`stdin`中读入数据，而`fscanf`函数则从它的第一个参数所指定的流中读入内容：

```C
scanf("%d %d", &x, &y); // 从键盘上读取
fscanf(fileptr, "%d %d", &x, &y); // 从执行的文件中读取
```

如果发生输入失败或者匹配失败，那么`...scanf`函数会提前返回。如果在读入任何数据项之前发生输入失败，那么会返回`EOF`。

在C程序中测试`scanf`函数的返回值的循环很普遍。例如，下列循环逐个读取一串整数，在首个遇到问题的符号处停止：

```C
while (scanf("%d", &i) == 1) {
    ...
}
```

