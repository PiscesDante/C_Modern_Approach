# 第16章 结构、联合和枚举

* 结构可能是具有不同类型的值（成员）的集合。
* 联合和结构类似，但是联合的成员共享同一个存储空间。
* 枚举是一种整数类型，其值由程序员命名。

## 16.1 结构变量

数组的两个重要特性：

* 数组的元素具有相同的类型；
* 为了选择数组元素需要指明元素的位置（循秩访问）；

结构的元素（成员）可能具有不同的类型。而且每个结构成员都有名字，所以为了选择特定的结构成员需要指明其对应的名字，而不是它的位置。

### 16.1.1 结构变量的声明

如果设计一个存储零件信息的结构：

```C
struct {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
} part1, part2;
```

每个结构变量都有三个成员：number，name和on_hand。`struct {...}`指明了类型，**而part1和part2则是具有上述类型的变量**。

结构的成员在内存中是按照**声明的顺序**存储的。

每个结构代表一种新的作用域。任何在结构内部声明的名字都不会和程序中的其他名字冲突。

### 16.1.2 结构变量的初始化

和数组一样，结构变量也可以在声明的同时进行初始化：

```C
struct {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
} part1 = { 528, "Disk", 10 },
  part2 = { 914, "Cable", 5 };
```

结构初始化式遵循的原则类似于数组初始化的原则。用于结构初始化式的表达式必须是常量。

### 16.1.3 指定初始化（C99）

初始化可以被指定：

```C
struct {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
} part1 = { .number = 528, .name = "Disk", .on_hand = 10 };
```

点运算符和成员名称的组合称为**指示符**。

指定初始化的优势：

* 易读且容易进行验证。
* 初始化式中的值得顺序**不需要**与结构中成员的顺序一致。

无指示符和有指示符的形式不能混用。

### 16.1.4 对结构的操作

结构成员是通过名字而不是位置进行访问的。我们需要使用**点运算符**来访问结构的成员。点运算符的优先级几乎高于所有其他运算符。

结构可以进行赋值：`part2 = part1;`

对结构进行复制时，嵌在其中的数组成员也可以得到复制，一些程序员利用这个性质来产生恐的结构，以封装稍后将进行复制的数组。

除了赋值运算，C语言没有提供其他用于整个结构的操作。特别是不能使用相等或者不等运算符来判断关系。

## 16.2 结构类型

C语言允许定义结构类型的名字。C语言提供了两种命名结构的方法：

* 声明“结构标记”；
* 也可以使用typedef来定义类型名；

### 16.2.1 结构标记的声明

结构标记是用于标识某种特定结构的名字：

```C
struct Part {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
};
```

其中Part就是这个结构的标记，右花括号的分号是必不可少的，它表示声明结束。

一旦标记了某种结构，就可以用结构的标记来声明变量了：

```C
struct Part {
    int number;
    char name[NAME_LEN + 1];
    int on_hand;
};

void func() {
    struct Part p1; // 不能通过漏掉单词struct来缩写这个声明
    // Part p1; 这样的声明在C语言中是错误的！必须加上struct关键字
    // ...
}
```

### 16.2.2 结构类型的定义

除了声明结构标记，还可以使用typedef来定义真实的类型名：

```C
typedef struct {
    int number;
    char name[20];
    int on_hand;
} Part;
```

注意：**<u>类型Part的名字必须出现在定义的末尾，而不是在struct的后面</u>**。

使用这种方式声明的Part就是个彻底的类型，所以在声明变量的时候可以直接当作类型来使用，而不用加上struct关键字。

### 16.2.3 结构作为参数和返回值

函数可以有结构类型的实际参数和返回值：

```C
#include <stdio.h>
#include <string.h>

struct Part {
    int number;
    char name[20];
    int on_hand;
};

void print_part(struct Part p)
{
    printf("Part number: %d\n", p.number);
    printf("Part name: %s\n", p.name);
    printf("Quantity on hand: %d\n", p.on_hand);
}

struct Part build_part(int number, const char* name, int on_hand)
{ // 这种其实就是构造函数的最初形态
    struct Part p;
    p.number = number;
    strcpy(p.name, name);
    p.on_hand = on_hand;
    return p;
}
```

传递指向结构的指针来代替传递结构本身是非常明智的做法。相同的，也可以使用返回传入的指针来减少开销。

当然还有一种情况就是对象本身不允许进行复制。

### 16.2.4 复合字面量（C99）

复合字面量可以用于“实时”创建一个结构，而不需要将其存储在变量中。

## 16.3 嵌套的数组和结构

新的可能性：成员是结构的结构，元素是结构的数组。

### 16.3.1 嵌套的结构

### 16.3.2 结构数组

数组和结构最常见的组合之一就是**其元素为结构的数组**。这类数组可以用作简单的数据库。

### 16.3.3 结构数组的初始化

## 16.4 联合

联合也是由一个或者多个成员构成的，而且这些成员可能具有不同的类型。但是，编译器只为联合中最大的成员分配足够的内存空间。联合的成员在这个空间内彼此覆盖。这样的一个结果是，给一个成员赋予新值也会改变其他成员的值。

### 16.4.1 用联合来节省空间

### 16.4.2 用联合来构造混合的数据结构

### 16.4.3 为联合添加“标记字段”

## 16.5 枚举

有时我们需要变量只具有少量意义的值，比方说布尔量应该只有真和假，扑克的花色只有梅花，方片，红桃和黑桃。枚举就是这样的一种数据类型，枚举类型是一种值由程序员列出的类型，而且程序员必须为每个值命名。

### 16.5.1 枚举标记和类型名

